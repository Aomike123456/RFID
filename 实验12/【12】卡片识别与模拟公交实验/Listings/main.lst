C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:43:39 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /******************************************************************
   2           * 实验名称：卡片识别与模拟公交实验
   3           * 可配书籍：上册-《深入浅出STC8增强型51单片机进阶攻略》已经出版
   4                       下册-《深入浅出STC8增强型51单片机实战攻略》还在写作
   5           * 书籍备注：龙顺宇编著 清华大学出版社出版
   6           * 淘宝店铺：https://520mcu.taobao.com/
   7           * 实验平台：思修电子工作室SX-RFID-B低频ID识别与应用开发板 Long
   8           * 芯片型号：STC8G1K08/17（微调后可移植至STC8A/F/C/G/H系列单片机）
   9           * 时钟说明：芯片内部12MHz，在使用STC-ISP软件时需要先配置然后下载
  10           *           到单片机使得时钟配置生效。
  11           * 实验说明：断电前提下向开发板插入1602液晶模块，然后用USB线插入到
  12           Uart-USB接口给开发板供电，做好STC-ISP配置并下载程序，观察1602液晶
  13           上的显示情况（第一行显示“IDT：”，第二行显示“Num：”），“IDT”是卡片
  14           类型，有学生卡和老年卡两种（学生卡打折扣费，老年卡免费乘车），除
  15           此之外都是用户卡（正常收费），“Num”是卡片的实际卡号，我们在开发板
  16           上方5-15cm处放置卡片即可识别卡片类型并播报扣费提示，以此模拟公交
  17           场景，学习卡号识别、身份验证等功能实现。
  18          ******************************************************************/
  19          #include  "STC8G.h"       //主控芯片的头文件
  20          #include  "intrins.h"     //因为要用到nop()函数故而包含此文件
  21          /************************常用数据类型定义*************************/
  22          #define u8  uint8_t
  23          #define u16 uint16_t
  24          #define u32 uint32_t
  25          typedef unsigned char    uint8_t;
  26          typedef unsigned int     uint16_t;
  27          typedef unsigned long    uint32_t;
  28          /************************端口/引脚定义区域************************/
  29          sbit Mcode=P3^2;          //曼彻斯特码输入端
  30          sbit ROTP=P1^7;           //OTP语音芯片复位脚
  31          sbit DATA=P1^5;           //OTP语音芯片数据脚
  32          sbit BUSY=P1^4;           //OTP语音芯片判忙脚
  33          sbit LCDRS=P3^6;          //LCD1602数据/命令选择端口
  34          sbit LCDEN=P3^7;          //LCD1602使能信号端口
  35          #define LCDDATA  P1       //LCD1602数据端口（仅用DB4至DB7）
  36          /************************用户自定义数据区域***********************/
  37          #define TIME_OUT  256     //最大超时阈值
  38          u8 table1[]="IDT:            ";//LCD1602显示卡片类型
  39          u8 table2[]="Num:            ";//LCD1602显示卡片卡号
  40          #define ID1 319631138UL   //学生卡（可按需设定和修改）
  41          #define ID2 319635063UL   //老年卡（可按需设定和修改）
  42          /*1:不放内容，2:滴（音效），3:错误提示音（音效），4:欢迎使用思修
  43          电子射频识别开发板，5:模拟门禁模式，6:模拟公交模式，7:刷卡成功，
  44          8:十位卡号为，9:八位卡号为，10:0，11:1，12:2，13:3，14:4，15:5，
  45          16:6，17:7，18:8，19:9，20:管理卡，21:用户卡，22:学生卡，23:老年
  46          卡，24:卡片有效，解锁成功，25:卡片非法，解锁失败，26:按键，27:识
  47          别成功，28:扣费成功，29:免费乘车*/
  48          /**************************函数声明区域***************************/
  49          void delay(u16 Count);    //延时函数
  50          void Delay150us(void);    //150us延时函数
  51          void delay384us(void);    //384us延时函数
  52          void IO_init(void);       //IO初始化函数
  53          void SYSCLK_CCO(u8 TYPE,u8 SET_F,u8 SET_P);//系统时钟输出函数
  54          void LCD1602_Write(u8 cmdordata,u8 writetype);
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:43:39 PAGE 2   

  55          //写入液晶模组命令或数据函数
  56          void LCD1602_init(void);  //LCD1602初始化函数
  57          void LCD1602_DIS(void);   //显示字符函数
  58          void LCD1602_DIS_CHAR(u8 x,u8 y,u8 z);//在设定地址写入字符数据函数
  59          void TTS(u8 num);         //OTP语音合成函数
  60          u32 Read_Card(void);      //读卡函数
  61          /***************************主函数区域****************************/
  62          void main(void)
  63          {
  64   1        u32 SN=0;               //定义卡号接收变量
  65   1        static u8 bit10_0,bit10_1,bit10_2,bit10_3,bit10_4,bit10_5,\
  66   1        bit10_6,bit10_7,bit10_8,bit10_9;//定义10位卡号的每一位
  67   1        IO_init();              //IO初始化
  68   1        SYSCLK_CCO(1,96,1);     //P1.6输出96分频的内部高速时钟12M/96=125kHz
  69   1        LCDEN=1;delay(200);     //使能置“1”（防止复位乱码）
  70   1        LCDEN=0;delay(200);     //使能清“0”（防止复位乱码）
  71   1        LCD1602_init();         //LCD1602初始化
  72   1        delay(200);             //延时等待稳定
  73   1        LCD1602_DIS();          //显示字符效果
  74   1        TTS(1);while(!BUSY);    //播报1段并等待完成（无内容）
  75   1        TTS(6);while(!BUSY);    //播报6段并等待完成（模拟公交模式）
  76   1        while(1)
  77   1        {
  78   2          SN=Read_Card();       //读取卡号数据
  79   2          if(SN)                //若卡号不为0，即有效卡号
  80   2          {
  81   3            //完成10位卡号的取位
  82   3            bit10_0=SN/1000000000;                //取出10位卡号第1位
  83   3            bit10_1=SN%1000000000/100000000;      //取出10位卡号第2位
  84   3            bit10_2=SN%100000000/10000000;        //取出10位卡号第3位
  85   3            bit10_3=SN%10000000/1000000;          //取出10位卡号第4位
  86   3            bit10_4=SN%1000000/100000;            //取出10位卡号第5位
  87   3            bit10_5=SN%100000/10000;              //取出10位卡号第6位
  88   3            bit10_6=SN%10000/1000;                //取出10位卡号第7位
  89   3            bit10_7=SN%1000/100;                  //取出10位卡号第8位
  90   3            bit10_8=SN%100/10;                    //取出10位卡号第9位
  91   3            bit10_9=SN%10;                        //取出10位卡号第10位
  92   3            //显示10位卡号
  93   3            LCD1602_DIS_CHAR(2,5, bit10_0+0x30);  //显示10位卡号第1位
  94   3            LCD1602_DIS_CHAR(2,6, bit10_1+0x30);  //显示10位卡号第2位
  95   3            LCD1602_DIS_CHAR(2,7, bit10_2+0x30);  //显示10位卡号第3位
  96   3            LCD1602_DIS_CHAR(2,8, bit10_3+0x30);  //显示10位卡号第4位
  97   3            LCD1602_DIS_CHAR(2,9, bit10_4+0x30);  //显示10位卡号第5位
  98   3            LCD1602_DIS_CHAR(2,10,bit10_5+0x30);  //显示10位卡号第6位
  99   3            LCD1602_DIS_CHAR(2,11,bit10_6+0x30);  //显示10位卡号第7位
 100   3            LCD1602_DIS_CHAR(2,12,bit10_7+0x30);  //显示10位卡号第8位
 101   3            LCD1602_DIS_CHAR(2,13,bit10_8+0x30);  //显示10位卡号第9位
 102   3            LCD1602_DIS_CHAR(2,14,bit10_9+0x30);  //显示10位卡号第10位
 103   3            switch(SN)                  //播报并显示卡片类型
 104   3            {
 105   4              case ID1:
 106   4              {
 107   5                //显示卡片类型为“Student”
 108   5                LCD1602_DIS_CHAR(1,5, 'S');
 109   5                LCD1602_DIS_CHAR(1,6, 't');
 110   5                LCD1602_DIS_CHAR(1,7, 'u');
 111   5                LCD1602_DIS_CHAR(1,8, 'd');
 112   5                LCD1602_DIS_CHAR(1,9, 'e');
 113   5                LCD1602_DIS_CHAR(1,10,'n');
 114   5                LCD1602_DIS_CHAR(1,11,'t');
 115   5                TTS(1);while(!BUSY);    //播报1段并等待完成（无内容）
 116   5                TTS(2);while(!BUSY);    //播报2段并等待完成（滴）
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:43:39 PAGE 3   

 117   5                TTS(22);while(!BUSY);   //播报22段并等待完成（学生卡）
 118   5                TTS(28);while(!BUSY);   //播报28段并等待完成（扣费成功）          
 119   5              }break;
 120   4              case ID2:
 121   4              {
 122   5                //显示卡片类型为“Old Man”
 123   5                LCD1602_DIS_CHAR(1,5, 'O');
 124   5                LCD1602_DIS_CHAR(1,6, 'l');
 125   5                LCD1602_DIS_CHAR(1,7, 'd');
 126   5                LCD1602_DIS_CHAR(1,8, ' ');
 127   5                LCD1602_DIS_CHAR(1,9, 'M');
 128   5                LCD1602_DIS_CHAR(1,10,'a');
 129   5                LCD1602_DIS_CHAR(1,11,'n');
 130   5                TTS(1);while(!BUSY);    //播报1段并等待完成（无内容）
 131   5                TTS(2);while(!BUSY);    //播报2段并等待完成（滴）
 132   5                TTS(23);while(!BUSY);   //播报23段并等待完成（老年卡）
 133   5                TTS(29);while(!BUSY);   //播报29段并等待完成（免费乘车）  
 134   5              }break;
 135   4              default:
 136   4              {
 137   5                //显示卡片类型为“GenUser”
 138   5                LCD1602_DIS_CHAR(1,5, 'G');
 139   5                LCD1602_DIS_CHAR(1,6, 'e');
 140   5                LCD1602_DIS_CHAR(1,7, 'n');
 141   5                LCD1602_DIS_CHAR(1,8, 'U');
 142   5                LCD1602_DIS_CHAR(1,9, 's');
 143   5                LCD1602_DIS_CHAR(1,10,'e');
 144   5                LCD1602_DIS_CHAR(1,11,'r');
 145   5                TTS(1);while(!BUSY);    //播报1段并等待完成（无内容）
 146   5                TTS(2);while(!BUSY);    //播报2段并等待完成（滴）
 147   5                TTS(21);while(!BUSY);   //播报21段并等待完成（用户卡）
 148   5                TTS(28);while(!BUSY);   //播报28段并等待完成（扣费成功）          
 149   5              }break;
 150   4            }
 151   3            SN=0;//清零卡号
 152   3          }
 153   2        }
 154   1      }
 155          /****************************************************************/
 156          //延时函数delay()，有形参Count用于控制延时函数执行次数，无返回值
 157          /****************************************************************/
 158          void delay(u16 Count)
 159          {
 160   1        u8 i,j;
 161   1        while (Count--)
 162   1        {
 163   2          for(i=0;i<50;i++)
 164   2            for(j=0;j<20;j++);
 165   2        }
 166   1      }
 167          /********************************************************************/
 168          //150us延时函数Delay150us()，无形参，无返回值，这是用STC-ISP算出
 169          //来的150us延时，此延时可以不严格，但应大于50us小于200us
 170          /********************************************************************/
 171          void Delay150us(void)//@12MHz
 172          {
 173   1        u8 i, j;
 174   1        _nop_();
 175   1        _nop_();
 176   1        i=3;
 177   1        j=83;
 178   1        do
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:43:39 PAGE 4   

 179   1        {
 180   2          while(--j);
 181   2        } while(--i);
 182   1      }
 183          /****************************************************************/
 184          //384us延时函数delay384us()，无形参，无返回值，这是用STC-ISP算出
 185          //来的384us延时，此延时可以不严格，但应大于256us小于512us
 186          /****************************************************************/
 187          void delay384us(void)//@12MHz
 188          {
 189   1        u8 i, j;
 190   1        _nop_();
 191   1        _nop_();
 192   1        i=6;
 193   1        j=249;
 194   1        do
 195   1        {
 196   2          while(--j);
 197   2        } while(--i);
 198   1      }
 199          /****************************************************************/
 200          //IO初始化函数IO_Init()，无形参，无返回值
 201          /****************************************************************/
 202          void IO_init(void)
 203          {
 204   1        //配置P1.6为推挽/强上拉模式
 205   1        P1M0|=0x40;     //P1M0.6=1
 206   1        P1M1&=0xBF;     //P1M1.6=0
 207   1        //配置P3.2为准双向/弱上拉模式
 208   1        P3M0&=0xFB;     //P3M0.2=0
 209   1        P3M1&=0xFB;     //P3M1.2=0
 210   1        //配置P3.6-7为准双向/弱上拉模式
 211   1        P3M0&=0x3F;     //P3M0.6-7=0
 212   1        P3M1&=0x3F;     //P3M1.6-7=0
 213   1        //配置P1.0-3为准双向/弱上拉模式
 214   1        P1M0&=0xF0;     //P1M0.0-3=0
 215   1        P1M1&=0xF0;     //P1M1.0-3=0
 216   1        //配置P1.4为准双向/弱上拉模式
 217   1        P1M0&=0xEF;     //P1M0.4=0
 218   1        P1M1&=0xEF;     //P1M1.4=0
 219   1        //配置P1.5为推挽输出模式
 220   1        P1M0|=0x20;     //P1M0.5=1
 221   1        P1M1&=0xDF;     //P1M1.5=0
 222   1        //配置P1.7为推挽输出模式
 223   1        P1M0|=0x80;     //P1M0.7=1
 224   1        P1M1&=0x7F;     //P1M1.7=0
 225   1        delay(10);      //等待I/O模式配置稳定
 226   1        ROTP=1;         //拉高复位引脚
 227   1        DATA=1;         //拉高数据引脚
 228   1      }
 229          /********************************************************************/
 230          //系统时钟输出函数SYSCLK_CCO()，有形参TYPE用于选择时钟源（0-外部时钟）
 231          //（1-片内高速时钟）（2-片内低速时钟），有形参SET_F用于指定时钟源
 232          //分频系数，有形参SET_P用于指定输出引脚的选择（P5.4/P1.6）无返回值
 233          /********************************************************************/
 234          void SYSCLK_CCO(u8 TYPE,u8 SET_F,u8 SET_P)
 235          {
 236   1        P_SW2|=0x80;          //允许访问扩展特殊功能寄存器XSFR
 237   1        switch(TYPE)
 238   1        {
 239   2          case 0:
 240   2          {
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:43:39 PAGE 5   

 241   3            XOSCCR|=0xC0;     //使能外部晶体振荡器
 242   3            while(!(XOSCCR&0x01));//等待外部时钟稳定
 243   3            //配置MCKSEL[1:0]=“01”，选择外部时钟
 244   3            CLKSEL&=0xFD;     //清零MCKSEL[1:0]的高位
 245   3            CLKSEL|=0x01;     //配置MCKSEL[1:0]的低位
 246   3          }break;   
 247   2          case 1:             //若选择片内高速时钟，则无需配置时钟选择
 248   2          {}break;
 249   2          case 2:
 250   2          {
 251   3            IRC32KCR|=0x80;   //使能内部32kHz低速IRC控制寄存器
 252   3            while(!(IRC32KCR&0x01));//等待内部低速时钟稳定
 253   3            CLKSEL|=0x03;     //配置MCKSEL[1:0]=“11”选择内部低速IRC时钟
 254   3          }break;
 255   2        }
 256   1        switch(SET_F)
 257   1        {
 258   2          case 1:{MCLKOCR&=0x80;MCLKOCR|=0x01;}break;   //Fsysclk/1
 259   2          case 2:{MCLKOCR&=0x80;MCLKOCR|=0x02;}break;   //Fsysclk/2
 260   2          case 4:{MCLKOCR&=0x80;MCLKOCR|=0x04;}break;   //Fsysclk/4
 261   2          case 8:{MCLKOCR&=0x80;MCLKOCR|=0x08;}break;   //Fsysclk/8
 262   2          case 16:{MCLKOCR&=0x80;MCLKOCR|=0x10;}break;  //Fsysclk/16
 263   2          case 32:{MCLKOCR&=0x80;MCLKOCR|=0x20;}break;  //Fsysclk/32
 264   2          case 64:{MCLKOCR&=0x80;MCLKOCR|=0x40;}break;  //Fsysclk/64
 265   2          case 96:{MCLKOCR&=0x80;MCLKOCR|=0x60;}break;  //Fsysclk/96
 266   2          case 127:{MCLKOCR&=0x80;MCLKOCR|=0x7F;}break; //Fsysclk/127
 267   2        }
 268   1        if(SET_P==0)
 269   1          MCLKOCR&=0x7F;      //配置时钟由P5.4引脚输出
 270   1        else
 271   1          MCLKOCR|=0x80;      //配置时钟由P1.6引脚输出
 272   1        P_SW2&=0x7F;          //结束并关闭XSFR访问
 273   1      }
 274          /********************************************************************/
 275          //LCD1602初始化函数LCD1602_init()，无形参和返回值
 276          /********************************************************************/
 277          void LCD1602_init(void)
 278          {
 279   1        LCD1602_Write(0x28,0);delay(10);//数据总线为4位，显示2行，5*7点阵/每字符
 280   1        LCDEN=1;delay(10);//使能置“1”
 281   1        LCDEN=0;delay(10);//使能清“0”
 282   1        LCD1602_Write(0x0C,0);delay(10);//设置开显示，不显示光标
 283   1        LCD1602_Write(0x06,0);delay(10);//写入新数据后显示屏整体不移动仅光标右移
 284   1        LCD1602_Write(0x01,0);delay(10);//写入清屏命令
 285   1      }
 286          /********************************************************************/
 287          //显示字符函数LCD1602_DIS()，无形参和返回值
 288          /********************************************************************/
 289          void LCD1602_DIS(void)
 290          {
 291   1        u8 i;                 //定义控制循环变量i
 292   1        LCD1602_Write(0x80,0);//选择第一行
 293   1        delay(5);             //延时等待1602稳定
 294   1        for(i=0;i<16;i++)
 295   1        {
 296   2            LCD1602_Write(table1[i],1);//写入table1[]内容
 297   2            delay(1);
 298   2        }
 299   1        LCD1602_Write(0xC0,0);//选择第二行
 300   1        delay(5);             //延时等待1602稳定
 301   1        for(i=0;i<16;i++)
 302   1        {
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:43:39 PAGE 6   

 303   2            LCD1602_Write(table2[i],1);//写入table2[]内容
 304   2            delay(1);
 305   2        }
 306   1      }
 307          /********************************************************************/
 308          //写入液晶模组命令或数据函数LCD1602_Write()，有形参cmdordata
 309          //和writetype，无返回值
 310          /********************************************************************/
 311          void LCD1602_Write(u8 cmdordata,u8 writetype)
 312          {
 313   1        u8 temp=0;                //定义数据处理中间变量
 314   1        LCDRS=writetype;          //判断写入类型0为命令1为数据
 315   1        delay(2);                 //延时等待稳定
 316   1        LCDDATA&=0xF0;            //清数据引脚
 317   1        temp=cmdordata>>4;        //高四位移到低四位
 318   1        LCDDATA|=temp&0x0F;       //写高四位
 319   1        LCDEN=1;delay(2);         //使能置“1”
 320   1        LCDEN=0;delay(2);         //使能清“0”
 321   1        LCDDATA&=0xF0;            //清数据引脚
 322   1        LCDDATA|=cmdordata&0x0F;  //写低四位
 323   1        LCDEN=1;delay(2);         //使能置“1”
 324   1        LCDEN=0;delay(2);         //使能清“0”
 325   1      }
 326          /********************************************************************/
 327          //设定地址写入字符函数LCD1602_DIS_CHAR()，有形参x、y、z无返回值
 328          //x表示1602液晶的行，y表示列地址，z表示欲写入的字符
 329          /********************************************************************/
 330          void LCD1602_DIS_CHAR(u8 x,u8 y,u8 z)
 331          {
 332   1        u8 address;
 333   1        if(x==1)            //若欲显示在第一行
 334   1          address=0x80+y;   //第一行的行首地址+列地址
 335   1        else
 336   1          address=0xC0+y;   //第二行的行首地址+列地址
 337   1        LCD1602_Write(address,0);   //设定显示地址
 338   1        LCD1602_Write(z,1); //写入字符数据
 339   1      }
 340          /********************************************************************/
 341          //OTP语音合成函数TTS_Prosser(),无形参，无返回值
 342          /********************************************************************/
 343          void TTS(u8 num)
 344          {
 345   1        ROTP=1;         //拉高复位引脚
 346   1        Delay150us();   //保持150us
 347   1        ROTP=0;         //拉低复位引脚
 348   1        Delay150us();   //保持150us
 349   1        ROTP=1;         //拉高复位引脚
 350   1        Delay150us();   //保持150us
 351   1        ROTP=0;         //拉低复位引脚
 352   1        Delay150us();   //保持150us
 353   1        while(num>0)    //若选定播放段地址不为0，则正常播报
 354   1        {
 355   2          DATA=1;       //拉高数据引脚
 356   2          Delay150us(); //保持150us
 357   2          DATA=0;       //拉高数据引脚
 358   2          Delay150us(); //保持150us
 359   2          num--;        //发出num个脉冲指定要播报的段
 360   2        }
 361   1      }
 362          /********************************************************************/
 363          //读卡函数Read_Card()，无形参，有返回值temp
 364          /********************************************************************/
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:43:39 PAGE 7   

 365          u32 Read_Card(void)
 366          {
 367   1        u8 i=0;                   //起始位循环控制变量
 368   1        u8 timeout;               //超时计数变量
 369   1        u8 timeout_flag;          //超时标志
 370   1        u8 row,col;               //行列变量
 371   1        u8 row_parity;            //行校验变量
 372   1        u8 col_parity[5];         //列校验变量
 373   1        u8 M_data;                //数据位变量
 374   1        u32 temp;                 //卡号变量
 375   1        u32 search=0;             //搜索次数变量
 376   1        while(1)                  //进行完整的读卡过程
 377   1        {   
 378   2          //***************************************************
 379   2          if(search==10)          //若10次搜索都未发现有效数据帧
 380   2            return 0;             //则返回0
 381   2          else                    //否则
 382   2          search++;               //搜索次数值自增
 383   2          timeout=0;              //超时值清零
 384   2          //***************************************************
 385   2          while(Mcode==0)         //等待接收引脚出现低电平
 386   2          {
 387   3            if(timeout==TIME_OUT) //若超时值等于设定阈值
 388   3              break;              //直接跳出本次搜索
 389   3            else                  //若超时值小于设定阈值
 390   3              timeout++;          //超时值自增
 391   3          }
 392   2          //***************************************************
 393   2          if(timeout==100)        //若超时值等于100
 394   2            continue;             //结束本次搜索
 395   2          else                    //否则
 396   2            timeout=0;            //超时值清零
 397   2          //***************************************************
 398   2          delay384us();           //延时384us
 399   2          if(Mcode)               //开始寻找帧头起始位
 400   2          {  
 401   3            for(i=0;i<8;i++)      //循环8次判断和处理过程
 402   3            {   
 403   4              timeout=0;          //先把超时值清零
 404   4              while(Mcode)        //等待接收引脚为高电平
 405   4              { 
 406   5                if(timeout==TIME_OUT)   //若超时值等于设定阈值
 407   5                {   
 408   6                  timeout_flag=1;break; //判定为超时事件，直接退出
 409   6                }
 410   5                else timeout++;   //否则超时值自增
 411   5              }  
 412   4              delay384us();       //再延时384us，判断下一个位
 413   4              if(Mcode&&timeout_flag==0);
 414   4              //判断下一位是否为1且超时标指是否为0
 415   4              else                //两个条件中若有其一不满足
 416   4                break;            //则直接退出         
 417   4            }
 418   3            //***************************************************
 419   3            if(timeout_flag)      //若超时标志为1
 420   3            {   
 421   4              timeout_flag=0;continue;//则清零标志并退出本次循环
 422   4            }
 423   3            else;
 424   3            //***************************************************
 425   3            if(i==8)//若i=8，则说明帧头已被识别，现在开始接受数据
 426   3            { 
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:43:39 PAGE 8   

 427   4              timeout_flag=0;     //清零超时标志
 428   4              timeout=0;          //清零超时值
 429   4              while(Mcode)        //等待接收引脚为高电平
 430   4              {  
 431   5                if(timeout==TIME_OUT)   //若超时值等于设定阈值
 432   5                { 
 433   6                  timeout_flag=0;break; //判定为超时事件，直接退出
 434   6                }
 435   5                else timeout++;   //否则超时值自增
 436   5              }   
 437   4              if(timeout_flag)    //若超时标志为1 
 438   4              {
 439   5                timeout_flag=0;continue;//则清零标志并退出本次循环
 440   5              }
 441   4              else; 
 442   4              //***************************************************
 443   4              //将5个列校验值清零
 444   4              col_parity[0]=col_parity[1]=col_parity[2]=0;
 445   4              col_parity[3]=col_parity[4]=0;
 446   4              for(row=0;row<11;row++)
 447   4              //循环11次，接收11行数据（4个数据位+1个行校验值）
 448   4              {
 449   5                for(col=0,row_parity=0;col<5;col++)//接收数据每5个为一行
 450   5                {
 451   6                  delay384us();       //延时384us，判断下一个数据位
 452   6                  if(Mcode)
 453   6                    M_data=1;         //若接收引脚高电平，则数据位为1
 454   6                  else
 455   6                    M_data=0;         //否则，数据位为0
 456   6                  //***************************************************
 457   6                  if(col<4&&row<10)   //若接收数据位在0-3列且在1-10行内
 458   6                  //意思就是在有效数据区域内
 459   6                  {
 460   7                    temp<<=1;         //卡号变量左移1位
 461   7                    temp+=(u32)M_data;//把新的数据位加到卡号变量中
 462   7                  }
 463   6                  else;
 464   6                  //***************************************************
 465   6                  row_parity+=M_data; //将数据加到行校验变量
 466   6                  col_parity[col]+=M_data;//将数据加到列校验变量
 467   6                  //虽然第5列数据仅作校验，但也加上
 468   6                  timeout=0;          //清零超时值
 469   6                  while(Mcode==(bit)M_data) //等待接收引脚状态为停止位
 470   6                  {
 471   7                    if(timeout==TIME_OUT)   //若超时值等于设定阈值
 472   7                    { 
 473   8                      timeout_flag=1;break; //判定为超时事件，直接退出
 474   8                    }
 475   7                    else timeout++;   //否则超时值自增
 476   7                  }
 477   6                  if(timeout_flag)    //若超时标志为1 
 478   6                    break;            //则退出本次循环
 479   6                  else;
 480   6                }
 481   5                //***************************************************
 482   5                if(row<10)            //因为最后一行没有校验
 483   5                                      //所以要加限制
 484   5                {
 485   6                  if((row_parity&0x01)||timeout_flag)
 486   6                  //若校验出错或超时标识为1
 487   6                  {
 488   7                    temp=0;           //清零本次采集的卡号数据
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:43:39 PAGE 9   

 489   7                    timeout_flag=1;   //置位超时标志位
 490   7                    break;            //退出
 491   7                  }
 492   6                  else;
 493   6                }
 494   5                else;
 495   5              }
 496   4              //***************************************************
 497   4              //对最后接收的列校验进行判断并结束本次主循环
 498   4              if(timeout_flag||((col_parity[0]&0x01)&&\
 499   4                (col_parity[1]&0x01)&&(col_parity[2]&0x01)&&\
 500   4              (col_parity[3]&0x01)))
 501   4              {                 //最后一列是没有校验的                         
 502   5                timeout_flag=0; //清零超时标志位
 503   5                temp=0;         //清零本次采集的卡号数据
 504   5                continue;       //退出本次循环
 505   5              } 
 506   4              else
 507   4                return temp;    //将卡号数据返回
 508   4            }
 509   3            continue;           //退出本次循环
 510   3          }
 511   2          continue;             //退出本次循环
 512   2        }
 513   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1956    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     44      24
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
