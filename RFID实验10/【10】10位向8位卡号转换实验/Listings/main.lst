C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:42:45 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /******************************************************************
   2           * 实验名称：10位向8位卡号转换实验
   3           * 可配书籍：上册-《深入浅出STC8增强型51单片机进阶攻略》已经出版
   4                       下册-《深入浅出STC8增强型51单片机实战攻略》还在写作
   5           * 书籍备注：龙顺宇编著 清华大学出版社出版
   6           * 淘宝店铺：https://520mcu.taobao.com/
   7           * 实验平台：思修电子工作室SX-RFID-B低频ID识别与应用开发板 Long
   8           * 芯片型号：STC8G1K08/17（微调后可移植至STC8A/F/C/G/H系列单片机）
   9           * 时钟说明：芯片内部12MHz，在使用STC-ISP软件时需要先配置然后下载
  10           *           到单片机使得时钟配置生效。
  11           * 实验说明：断电前提下向开发板插入1602液晶模块，然后用USB线插到
  12           Uart-USB接口给开发板供电，做好STC-ISP配置并下载程序，观察1602液
  13           晶的显示情况（第一行显示“10b:”，第二行显示“08b:”）,我们在开发板
  14           上方5-15cm处放置卡片，此时液晶第一行会显示出10位卡号，第二行会显
  15           示8位卡号，以此学习Manchester解码方法和10位向8位卡号转换方法。
  16          ******************************************************************/
  17          #include  "STC8G.h"       //主控芯片的头文件
  18          #include  "intrins.h"     //因为要用到nop()函数故而包含此文件
  19          /************************常用数据类型定义*************************/
  20          #define u8  uint8_t
  21          #define u16 uint16_t
  22          #define u32 uint32_t
  23          typedef unsigned char    uint8_t;
  24          typedef unsigned int     uint16_t;
  25          typedef unsigned long    uint32_t;
  26          /************************端口/引脚定义区域************************/
  27          sbit Mcode=P3^2;          //曼彻斯特码输入端
  28          sbit LCDRS=P3^6;          //LCD1602数据/命令选择端口
  29          sbit LCDEN=P3^7;          //LCD1602使能信号端口
  30          #define LCDDATA  P1       //LCD1602数据端口（仅用DB4至DB7）
  31          /************************用户自定义数据区域***********************/
  32          u8 table1[]="10b:            ";//LCD1602显示10位卡号
  33          u8 table2[]="08b:            ";//LCD1602显示8位卡号
  34          #define TIME_OUT  256     //最大超时阈值
  35          /**************************函数声明区域***************************/
  36          void delay(u16 Count);    //延时函数
  37          void IO_init(void);       //IO初始化函数
  38          void SYSCLK_CCO(u8 TYPE,u8 SET_F,u8 SET_P);//系统时钟输出函数
  39          void LCD1602_Write(u8 cmdordata,u8 writetype);
  40          //写入液晶模组命令或数据函数
  41          void LCD1602_init(void);  //LCD1602初始化函数
  42          void LCD1602_DIS(void);   //显示字符函数
  43          void LCD1602_DIS_CHAR(u8 x,u8 y,u8 z);//在设定地址写入字符数据函数
  44          u32 Read_Card(void);      //读卡函数
  45          /***************************主函数区域****************************/
  46          void main(void)
  47          {
  48   1        u32 SN=0;               //定义卡号接收变量
  49   1        u16 a;                  //定义8位卡号的首部
  50   1        u32 b;                  //定义8位卡号的尾部
  51   1        IO_init();              //IO初始化  
  52   1        SYSCLK_CCO(1,96,1);     //P1.6输出96分频的内部高速时钟12M/96=125kHz
  53   1        LCDEN=1;delay(200);     //使能置“1”（防止复位乱码）
  54   1        LCDEN=0;delay(200);     //使能清“0”（防止复位乱码）
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:42:45 PAGE 2   

  55   1        LCD1602_init();         //LCD1602初始化
  56   1        delay(200);             //延时等待稳定
  57   1        LCD1602_DIS();          //显示字符效果
  58   1        while(1)
  59   1        {
  60   2          SN=Read_Card();       //读取卡号数据
  61   2          if(SN)                //若卡号不为0，即有效卡号
  62   2          {
  63   3            //显示10位卡号
  64   3            LCD1602_DIS_CHAR(1,5,SN/1000000000+0x30);
  65   3            LCD1602_DIS_CHAR(1,6,SN%1000000000/100000000+0x30);
  66   3            LCD1602_DIS_CHAR(1,7,SN%100000000/10000000+0x30);
  67   3            LCD1602_DIS_CHAR(1,8,SN%10000000/1000000+0x30);
  68   3            LCD1602_DIS_CHAR(1,9,SN%1000000/100000+0x30);
  69   3            LCD1602_DIS_CHAR(1,10,SN%100000/10000+0x30);
  70   3            LCD1602_DIS_CHAR(1,11,SN%10000/1000+0x30);
  71   3            LCD1602_DIS_CHAR(1,12,SN%1000/100+0x30);
  72   3            LCD1602_DIS_CHAR(1,13,SN%100/10+0x30);
  73   3            LCD1602_DIS_CHAR(1,14,SN%10+0x30);
  74   3            //显示8位卡号
  75   3            /*转换方法：10位卡号转换为十六进制数是4个字节, 第一个字节舍弃,
  76   3            第二个字节转换为8位卡号的前3位，第三个和第四个字节一起转换为8
  77   3            位卡号的后5位即可。例如：某卡片的十位卡号0319631142对应的十六
  78   3            进制形式为130D2F26，先把第一个字节“13”舍弃，把第二个字节“0D”转
  79   3            换为十进制就是13，第三个和第四个字节“2F26”转换为十进制就是12070，
  80   3            所以该卡片的8位形式就是13，12070。*/
  81   3            a=(SN/16/16/16/16/16%16)*16+(SN/16/16/16/16%16);
  82   3            LCD1602_DIS_CHAR(2,5,a/100+0x30);
  83   3            LCD1602_DIS_CHAR(2,6,a%100/10+0x30);
  84   3            LCD1602_DIS_CHAR(2,7,a%10+0x30);
  85   3            LCD1602_DIS_CHAR(2,8,',');
  86   3            b=(SN/16/16/16%16)*4096+(SN/16/16%16)*256+(SN/16%16)*16+(SN%16);
  87   3            LCD1602_DIS_CHAR(2,9,b/10000+0x30);
  88   3            LCD1602_DIS_CHAR(2,10,b%10000/1000+0x30);
  89   3            LCD1602_DIS_CHAR(2,11,b%1000/100+0x30);
  90   3            LCD1602_DIS_CHAR(2,12,b%100/10+0x30);
  91   3            LCD1602_DIS_CHAR(2,13,b%10+0x30);
  92   3          }
  93   2        }
  94   1      }
  95          /****************************************************************/
  96          //延时函数delay()，有形参Count用于控制延时函数执行次数，无返回值
  97          /****************************************************************/
  98          void delay(u16 Count)
  99          {
 100   1        u8 i,j;
 101   1        while (Count--)
 102   1        {
 103   2          for(i=0;i<50;i++)
 104   2            for(j=0;j<20;j++);
 105   2        }
 106   1      }
 107          /****************************************************************/
 108          //384us延时函数delay384us()，无形参，无返回值，这是用STC-ISP算出
 109          //来的384us延时，此延时可以不严格，但应大于256us小于512us
 110          /****************************************************************/
 111          void delay384us(void)//@12MHz
 112          {
 113   1        u8 i, j;
 114   1        _nop_();
 115   1        _nop_();
 116   1        i=6;
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:42:45 PAGE 3   

 117   1        j=249;
 118   1        do
 119   1        {
 120   2          while(--j);
 121   2        } while(--i);
 122   1      }
 123          /****************************************************************/
 124          //IO初始化函数IO_Init()，无形参，无返回值
 125          /****************************************************************/
 126          void IO_init(void)
 127          {
 128   1        //配置P1.6为推挽/强上拉模式
 129   1        P1M0|=0x40;     //P1M0.6=1
 130   1        P1M1&=0xBF;     //P1M1.6=0
 131   1        //配置P3.2为准双向/弱上拉模式
 132   1        P3M0&=0xFB;     //P3M0.2=0
 133   1        P3M1&=0xFB;     //P3M1.2=0
 134   1        //配置P3.6-7为准双向/弱上拉模式
 135   1        P3M0&=0x3F;     //P3M0.6-7=0
 136   1        P3M1&=0x3F;     //P3M1.6-7=0
 137   1        //配置P1.0-3为准双向/弱上拉模式
 138   1        P1M0&=0xF0;     //P1M0.0-3=0
 139   1        P1M1&=0xF0;     //P1M1.0-3=0
 140   1        delay(10);      //等待I/O模式配置稳定
 141   1      }
 142          /********************************************************************/
 143          //系统时钟输出函数SYSCLK_CCO()，有形参TYPE用于选择时钟源（0-外部时钟）
 144          //（1-片内高速时钟）（2-片内低速时钟），有形参SET_F用于指定时钟源
 145          //分频系数，有形参SET_P用于指定输出引脚的选择（P5.4/P1.6）无返回值
 146          /********************************************************************/
 147          void SYSCLK_CCO(u8 TYPE,u8 SET_F,u8 SET_P)
 148          {
 149   1        P_SW2|=0x80;          //允许访问扩展特殊功能寄存器XSFR
 150   1        switch(TYPE)
 151   1        {
 152   2          case 0:
 153   2          {
 154   3            XOSCCR|=0xC0;     //使能外部晶体振荡器
 155   3            while(!(XOSCCR&0x01));//等待外部时钟稳定
 156   3            //配置MCKSEL[1:0]=“01”，选择外部时钟
 157   3            CLKSEL&=0xFD;     //清零MCKSEL[1:0]的高位
 158   3            CLKSEL|=0x01;     //配置MCKSEL[1:0]的低位
 159   3          }break;   
 160   2          case 1:             //若选择片内高速时钟，则无需配置时钟选择
 161   2          {}break;
 162   2          case 2:
 163   2          {
 164   3            IRC32KCR|=0x80;   //使能内部32kHz低速IRC控制寄存器
 165   3            while(!(IRC32KCR&0x01));//等待内部低速时钟稳定
 166   3            CLKSEL|=0x03;     //配置MCKSEL[1:0]=“11”选择内部低速IRC时钟
 167   3          }break;
 168   2        }
 169   1        switch(SET_F)
 170   1        {
 171   2          case 1:{MCLKOCR&=0x80;MCLKOCR|=0x01;}break;   //Fsysclk/1
 172   2          case 2:{MCLKOCR&=0x80;MCLKOCR|=0x02;}break;   //Fsysclk/2
 173   2          case 4:{MCLKOCR&=0x80;MCLKOCR|=0x04;}break;   //Fsysclk/4
 174   2          case 8:{MCLKOCR&=0x80;MCLKOCR|=0x08;}break;   //Fsysclk/8
 175   2          case 16:{MCLKOCR&=0x80;MCLKOCR|=0x10;}break;  //Fsysclk/16
 176   2          case 32:{MCLKOCR&=0x80;MCLKOCR|=0x20;}break;  //Fsysclk/32
 177   2          case 64:{MCLKOCR&=0x80;MCLKOCR|=0x40;}break;  //Fsysclk/64
 178   2          case 96:{MCLKOCR&=0x80;MCLKOCR|=0x60;}break;  //Fsysclk/96
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:42:45 PAGE 4   

 179   2          case 127:{MCLKOCR&=0x80;MCLKOCR|=0x7F;}break; //Fsysclk/127
 180   2        }
 181   1        if(SET_P==0)
 182   1          MCLKOCR&=0x7F;      //配置时钟由P5.4引脚输出
 183   1        else
 184   1          MCLKOCR|=0x80;      //配置时钟由P1.6引脚输出
 185   1        P_SW2&=0x7F;          //结束并关闭XSFR访问
 186   1      }
 187          /********************************************************************/
 188          //LCD1602初始化函数LCD1602_init()，无形参和返回值
 189          /********************************************************************/
 190          void LCD1602_init(void)
 191          {
 192   1        LCD1602_Write(0x28,0);delay(10);//数据总线为4位，显示2行，5*7点阵/每字符
 193   1        LCDEN=1;delay(10);              //使能置“1”
 194   1        LCDEN=0;delay(10);              //使能清“0”
 195   1        LCD1602_Write(0x0C,0);delay(10);//设置开显示，不显示光标
 196   1        LCD1602_Write(0x06,0);delay(10);//写入新数据后显示屏整体不移动仅光标右移
 197   1        LCD1602_Write(0x01,0);delay(10);//写入清屏命令
 198   1      }
 199          /********************************************************************/
 200          //显示字符函数LCD1602_DIS()，无形参和返回值
 201          /********************************************************************/
 202          void LCD1602_DIS(void)
 203          {
 204   1        u8 i;                 //定义控制循环变量i
 205   1        LCD1602_Write(0x80,0);//选择第一行
 206   1        delay(5);             //延时等待1602稳定
 207   1        for(i=0;i<16;i++)
 208   1        {
 209   2            LCD1602_Write(table1[i],1);//写入table1[]内容
 210   2            delay(1);
 211   2        }
 212   1        LCD1602_Write(0xC0,0);//选择第二行
 213   1        delay(5);             //延时等待1602稳定
 214   1        for(i=0;i<16;i++)
 215   1        {
 216   2            LCD1602_Write(table2[i],1);//写入table2[]内容
 217   2            delay(1);
 218   2        }
 219   1      }
 220          /********************************************************************/
 221          //写入液晶模组命令或数据函数LCD1602_Write()，有形参cmdordata
 222          //和writetype，无返回值
 223          /********************************************************************/
 224          void LCD1602_Write(u8 cmdordata,u8 writetype)
 225          {
 226   1        u8 temp=0;                //定义数据处理中间变量
 227   1        LCDRS=writetype;          //判断写入类型0为命令1为数据
 228   1        delay(2);                 //延时等待稳定
 229   1        LCDDATA&=0xF0;            //清数据引脚
 230   1        temp=cmdordata>>4;        //高四位移到低四位
 231   1        LCDDATA|=temp&0x0F;       //写高四位
 232   1        LCDEN=1;delay(2);         //使能置“1”
 233   1        LCDEN=0;delay(2);         //使能清“0”
 234   1        LCDDATA&=0xF0;            //清数据引脚
 235   1        LCDDATA|=cmdordata&0x0F;  //写低四位
 236   1        LCDEN=1;delay(2);         //使能置“1”
 237   1        LCDEN=0;delay(2);         //使能清“0”
 238   1      }
 239          /********************************************************************/
 240          //设定地址写入字符函数LCD1602_DIS_CHAR()，有形参x、y、z无返回值
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:42:45 PAGE 5   

 241          //x表示1602液晶的行，y表示列地址，z表示欲写入的字符
 242          /********************************************************************/
 243          void LCD1602_DIS_CHAR(u8 x,u8 y,u8 z)
 244          {
 245   1        u8 address;
 246   1        if(x==1)            //若欲显示在第一行
 247   1          address=0x80+y;   //第一行的行首地址+列地址
 248   1        else
 249   1          address=0xC0+y;   //第二行的行首地址+列地址
 250   1        LCD1602_Write(address,0);   //设定显示地址
 251   1        LCD1602_Write(z,1); //写入字符数据
 252   1      }
 253          /********************************************************************/
 254          //读卡函数Read_Card()，无形参，有返回值temp
 255          /********************************************************************/
 256          u32 Read_Card(void)
 257          {
 258   1        u8 i=0;                   //起始位循环控制变量
 259   1        u8 timeout;               //超时计数变量
 260   1        u8 timeout_flag;          //超时标志
 261   1        u8 row,col;               //行列变量
 262   1        u8 row_parity;            //行校验变量
 263   1        u8 col_parity[5];         //列校验变量
 264   1        u8 M_data;                //数据位变量
 265   1        u32 temp;                 //卡号变量
 266   1        u32 search=0;             //搜索次数变量
 267   1        while(1)                  //进行完整的读卡过程
 268   1        {   
 269   2          //***************************************************
 270   2          if(search==10)          //若10次搜索都未发现有效数据帧
 271   2            return 0;             //则返回0
 272   2          else                    //否则
 273   2          search++;               //搜索次数值自增
 274   2          timeout=0;              //超时值清零
 275   2          //***************************************************
 276   2          while(Mcode==0)         //等待接收引脚出现低电平
 277   2          {
 278   3            if(timeout==TIME_OUT) //若超时值等于设定阈值
 279   3              break;              //直接跳出本次搜索
 280   3            else                  //若超时值小于设定阈值
 281   3              timeout++;          //超时值自增
 282   3          }
 283   2          //***************************************************
 284   2          if(timeout==100)        //若超时值等于100
 285   2            continue;             //结束本次搜索
 286   2          else                    //否则
 287   2            timeout=0;            //超时值清零
 288   2          //***************************************************
 289   2          delay384us();           //延时384us
 290   2          if(Mcode)               //开始寻找帧头起始位
 291   2          {  
 292   3            for(i=0;i<8;i++)      //循环8次判断和处理过程
 293   3            {   
 294   4              timeout=0;          //先把超时值清零
 295   4              while(Mcode)        //等待接收引脚为高电平
 296   4              { 
 297   5                if(timeout==TIME_OUT)   //若超时值等于设定阈值
 298   5                {   
 299   6                  timeout_flag=1;break; //判定为超时事件，直接退出
 300   6                }
 301   5                else timeout++;   //否则超时值自增
 302   5              }  
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:42:45 PAGE 6   

 303   4              delay384us();       //再延时384us，判断下一个位
 304   4              if(Mcode&&timeout_flag==0);
 305   4              //判断下一位是否为1且超时标指是否为0
 306   4              else                //两个条件中若有其一不满足
 307   4                break;            //则直接退出         
 308   4            }
 309   3            //***************************************************
 310   3            if(timeout_flag)      //若超时标志为1
 311   3            {   
 312   4              timeout_flag=0;continue;//则清零标志并退出本次循环
 313   4            }
 314   3            else;
 315   3            //***************************************************
 316   3            if(i==8)//若i=8，则说明帧头已被识别，现在开始接受数据
 317   3            { 
 318   4              timeout_flag=0;     //清零超时标志
 319   4              timeout=0;          //清零超时值
 320   4              while(Mcode)        //等待接收引脚为高电平
 321   4              {  
 322   5                if(timeout==TIME_OUT)   //若超时值等于设定阈值
 323   5                { 
 324   6                  timeout_flag=0;break; //判定为超时事件，直接退出
 325   6                }
 326   5                else timeout++;   //否则超时值自增
 327   5              }   
 328   4              if(timeout_flag)    //若超时标志为1 
 329   4              {
 330   5                timeout_flag=0;continue;//则清零标志并退出本次循环
 331   5              }
 332   4              else; 
 333   4              //***************************************************
 334   4              //将5个列校验值清零
 335   4              col_parity[0]=col_parity[1]=col_parity[2]=0;
 336   4              col_parity[3]=col_parity[4]=0;
 337   4              for(row=0;row<11;row++)
 338   4              //循环11次，接收11行数据（4个数据位+1个行校验值）
 339   4              {
 340   5                for(col=0,row_parity=0;col<5;col++)//接收数据每5个为一行
 341   5                {
 342   6                  delay384us();       //延时384us，判断下一个数据位
 343   6                  if(Mcode)
 344   6                    M_data=1;         //若接收引脚高电平，则数据位为1
 345   6                  else
 346   6                    M_data=0;         //否则，数据位为0
 347   6                  //***************************************************
 348   6                  if(col<4&&row<10)   //若接收数据位在0-3列且在1-10行内
 349   6                  //意思就是在有效数据区域内
 350   6                  {
 351   7                    temp<<=1;         //卡号变量左移1位
 352   7                    temp+=(u32)M_data;//把新的数据位加到卡号变量中
 353   7                  }
 354   6                  else;
 355   6                  //***************************************************
 356   6                  row_parity+=M_data; //将数据加到行校验变量
 357   6                  col_parity[col]+=M_data;//将数据加到列校验变量
 358   6                  //虽然第5列数据仅作校验，但也加上
 359   6                  timeout=0;          //清零超时值
 360   6                  while(Mcode==(bit)M_data) //等待接收引脚状态为停止位
 361   6                  {
 362   7                    if(timeout==TIME_OUT)   //若超时值等于设定阈值
 363   7                    { 
 364   8                      timeout_flag=1;break; //判定为超时事件，直接退出
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:42:45 PAGE 7   

 365   8                    }
 366   7                    else timeout++;   //否则超时值自增
 367   7                  }
 368   6                  if(timeout_flag)    //若超时标志为1 
 369   6                    break;            //则退出本次循环
 370   6                  else;
 371   6                }
 372   5                //***************************************************
 373   5                if(row<10)            //因为最后一行没有校验
 374   5                                      //所以要加限制
 375   5                {
 376   6                  if((row_parity&0x01)||timeout_flag)
 377   6                  //若校验出错或超时标识为1
 378   6                  {
 379   7                    temp=0;           //清零本次采集的卡号数据
 380   7                    timeout_flag=1;   //置位超时标志位
 381   7                    break;            //退出
 382   7                  }
 383   6                  else;
 384   6                }
 385   5                else;
 386   5              }
 387   4              //***************************************************
 388   4              //对最后接收的列校验进行判断并结束本次主循环
 389   4              if(timeout_flag||((col_parity[0]&0x01)&&\
 390   4                (col_parity[1]&0x01)&&(col_parity[2]&0x01)&&\
 391   4              (col_parity[3]&0x01)))
 392   4              {                 //最后一列是没有校验的                         
 393   5                timeout_flag=0; //清零超时标志位
 394   5                temp=0;         //清零本次采集的卡号数据
 395   5                continue;       //退出本次循环
 396   5              } 
 397   4              else
 398   4                return temp;    //将卡号数据返回
 399   4            }
 400   3            continue;           //退出本次循环
 401   3          }
 402   2          continue;             //退出本次循环
 403   2        }
 404   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2129    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     34      30
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
