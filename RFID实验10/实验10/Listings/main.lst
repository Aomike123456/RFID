C51 COMPILER V9.60.0.0   MAIN                                                              05/25/2025 18:28:08 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /******************************************************************
   2           * 实验名称：10位向8位卡号转换实验
   3          ******************************************************************/
   4          #include  "STC8G.h"       //主控芯片的头文件
   5          #include  "intrins.h"     //因为要用到nop()函数故而包含此文件
   6          /************************常用数据类型定义*************************/
   7          #define u8  uint8_t
   8          #define u16 uint16_t
   9          #define u32 uint32_t
  10          typedef unsigned char    uint8_t;
  11          typedef unsigned int     uint16_t;
  12          typedef unsigned long    uint32_t;
  13          /************************端口/引脚定义区域************************/
  14          sbit Mcode=P3^2;          //曼彻斯特码输入端
  15          sbit LCDRS=P3^6;          //LCD1602数据/命令选择端口
  16          sbit LCDEN=P3^7;          //LCD1602使能信号端口
  17          #define LCDDATA  P1       //LCD1602数据端口（仅用DB4至DB7）
  18          /************************用户自定义数据区域***********************/
  19          u8 table1[]="10b:            ";//LCD1602显示10位卡号
  20          u8 table2[]="08b:            ";//LCD1602显示8位卡号
  21          #define TIME_OUT  256     //最大超时阈值
  22          /**************************函数声明区域***************************/
  23          void delay(u16 Count);    //延时函数
  24          void IO_init(void);       //IO初始化函数
  25          void SYSCLK_CCO(u8 TYPE,u8 SET_F,u8 SET_P);//系统时钟输出函数
  26          void LCD1602_Write(u8 cmdordata,u8 writetype);
  27          //写入液晶模组命令或数据函数
  28          void LCD1602_init(void);  //LCD1602初始化函数
  29          void LCD1602_DIS(void);   //显示字符函数
  30          void LCD1602_DIS_CHAR(u8 x,u8 y,u8 z);//在设定地址写入字符数据函数
  31          u32 Read_Card(void);      //读卡函数
  32          /***************************主函数区域****************************/
  33          void main(void)
  34          {
  35   1        while(1)
  36   1        {
  37   2          
  38   2          
  39   2          
  40   2          
  41   2          
  42   2          
  43   2          
  44   2          
  45   2          
  46   2        }
  47   1      }
  48          /****************************************************************/
  49          //延时函数delay()，有形参Count用于控制延时函数执行次数，无返回值
  50          /****************************************************************/
  51          void delay(u16 Count)
  52          {
  53   1        u8 i,j;
  54   1        while (Count--)
C51 COMPILER V9.60.0.0   MAIN                                                              05/25/2025 18:28:08 PAGE 2   

  55   1        {
  56   2          for(i=0;i<50;i++)
  57   2            for(j=0;j<20;j++);
  58   2        }
  59   1      }
  60          /****************************************************************/
  61          //384us延时函数delay384us()，无形参，无返回值，这是用STC-ISP算出
  62          //来的384us延时，此延时可以不严格，但应大于256us小于512us
  63          /****************************************************************/
  64          void delay384us(void)//@12MHz
  65          {
  66   1        u8 i, j;
  67   1        _nop_();
  68   1        _nop_();
  69   1        i=6;
  70   1        j=249;
  71   1        do
  72   1        {
  73   2          while(--j);
  74   2        } while(--i);
  75   1      }
  76          /****************************************************************/
  77          //IO初始化函数IO_Init()，无形参，无返回值
  78          /****************************************************************/
  79          void IO_init(void)
  80          {
  81   1        //配置P1.6为推挽/强上拉模式
  82   1        P1M0|=0x40;     //P1M0.6=1
  83   1        P1M1&=0xBF;     //P1M1.6=0
  84   1        //配置P3.2为准双向/弱上拉模式
  85   1        P3M0&=0xFB;     //P3M0.2=0
  86   1        P3M1&=0xFB;     //P3M1.2=0
  87   1        //配置P3.6-7为准双向/弱上拉模式
  88   1        P3M0&=0x3F;     //P3M0.6-7=0
  89   1        P3M1&=0x3F;     //P3M1.6-7=0
  90   1        //配置P1.0-3为准双向/弱上拉模式
  91   1        P1M0&=0xF0;     //P1M0.0-3=0
  92   1        P1M1&=0xF0;     //P1M1.0-3=0
  93   1        delay(10);      //等待I/O模式配置稳定
  94   1      }
  95          /********************************************************************/
  96          //系统时钟输出函数SYSCLK_CCO()，有形参TYPE用于选择时钟源（0-外部时钟）
  97          //（1-片内高速时钟）（2-片内低速时钟），有形参SET_F用于指定时钟源
  98          //分频系数，有形参SET_P用于指定输出引脚的选择（P5.4/P1.6）无返回值
  99          /********************************************************************/
 100          void SYSCLK_CCO(u8 TYPE,u8 SET_F,u8 SET_P)
 101          {
 102   1        P_SW2|=0x80;          //允许访问扩展特殊功能寄存器XSFR
 103   1        switch(TYPE)
 104   1        {
 105   2          case 0:
 106   2          {
 107   3            XOSCCR|=0xC0;     //使能外部晶体振荡器
 108   3            while(!(XOSCCR&0x01));//等待外部时钟稳定
 109   3            //配置MCKSEL[1:0]=“01”，选择外部时钟
 110   3            CLKSEL&=0xFD;     //清零MCKSEL[1:0]的高位
 111   3            CLKSEL|=0x01;     //配置MCKSEL[1:0]的低位
 112   3          }break;   
 113   2          case 1:             //若选择片内高速时钟，则无需配置时钟选择
 114   2          {}break;
 115   2          case 2:
 116   2          {
C51 COMPILER V9.60.0.0   MAIN                                                              05/25/2025 18:28:08 PAGE 3   

 117   3            IRC32KCR|=0x80;   //使能内部32kHz低速IRC控制寄存器
 118   3            while(!(IRC32KCR&0x01));//等待内部低速时钟稳定
 119   3            CLKSEL|=0x03;     //配置MCKSEL[1:0]=“11”选择内部低速IRC时钟
 120   3          }break;
 121   2        }
 122   1        switch(SET_F)
 123   1        {
 124   2          case 1:{MCLKOCR&=0x80;MCLKOCR|=0x01;}break;   //Fsysclk/1
 125   2          case 2:{MCLKOCR&=0x80;MCLKOCR|=0x02;}break;   //Fsysclk/2
 126   2          case 4:{MCLKOCR&=0x80;MCLKOCR|=0x04;}break;   //Fsysclk/4
 127   2          case 8:{MCLKOCR&=0x80;MCLKOCR|=0x08;}break;   //Fsysclk/8
 128   2          case 16:{MCLKOCR&=0x80;MCLKOCR|=0x10;}break;  //Fsysclk/16
 129   2          case 32:{MCLKOCR&=0x80;MCLKOCR|=0x20;}break;  //Fsysclk/32
 130   2          case 64:{MCLKOCR&=0x80;MCLKOCR|=0x40;}break;  //Fsysclk/64
 131   2          case 96:{MCLKOCR&=0x80;MCLKOCR|=0x60;}break;  //Fsysclk/96
 132   2          case 127:{MCLKOCR&=0x80;MCLKOCR|=0x7F;}break; //Fsysclk/127
 133   2        }
 134   1        if(SET_P==0)
 135   1          MCLKOCR&=0x7F;      //配置时钟由P5.4引脚输出
 136   1        else
 137   1          MCLKOCR|=0x80;      //配置时钟由P1.6引脚输出
 138   1        P_SW2&=0x7F;          //结束并关闭XSFR访问
 139   1      }
 140          /********************************************************************/
 141          //LCD1602初始化函数LCD1602_init()，无形参和返回值
 142          /********************************************************************/
 143          void LCD1602_init(void)
 144          {
 145   1        while(1)
 146   1        {
 147   2          
 148   2          
 149   2        }
 150   1      }
 151          /********************************************************************/
 152          //显示字符函数LCD1602_DIS()，无形参和返回值
 153          /********************************************************************/
 154          void LCD1602_DIS(void)
 155          {
 156   1        while(1)
 157   1        {
 158   2          
 159   2          
 160   2          
 161   2          
 162   2          
 163   2          
 164   2        }
 165   1      }
 166          /********************************************************************/
 167          //写入液晶模组命令或数据函数LCD1602_Write()，有形参cmdordata
 168          //和writetype，无返回值
 169          /********************************************************************/
 170          void LCD1602_Write(u8 cmdordata,u8 writetype)
 171          {
 172   1        u8 temp=0;                //定义数据处理中间变量
 173   1        LCDRS=writetype;          //判断写入类型0为命令1为数据
 174   1        delay(2);                 //延时等待稳定
 175   1        LCDDATA&=0xF0;            //清数据引脚
 176   1        temp=cmdordata>>4;        //高四位移到低四位
 177   1        LCDDATA|=temp&0x0F;       //写高四位
 178   1        LCDEN=1;delay(2);         //使能置“1”
C51 COMPILER V9.60.0.0   MAIN                                                              05/25/2025 18:28:08 PAGE 4   

 179   1        LCDEN=0;delay(2);         //使能清“0”
 180   1        LCDDATA&=0xF0;            //清数据引脚
 181   1        LCDDATA|=cmdordata&0x0F;  //写低四位
 182   1        LCDEN=1;delay(2);         //使能置“1”
 183   1        LCDEN=0;delay(2);         //使能清“0”
 184   1      }
 185          /********************************************************************/
 186          //设定地址写入字符函数LCD1602_DIS_CHAR()，有形参x、y、z无返回值
 187          //x表示1602液晶的行，y表示列地址，z表示欲写入的字符
 188          /********************************************************************/
 189          void LCD1602_DIS_CHAR(u8 x,u8 y,u8 z)
 190          {
 191   1        while(1)
 192   1        {
 193   2          
 194   2          
 195   2          
 196   2          
 197   2          
 198   2          
 199   2          
 200   2          
 201   2          
 202   2        }
 203   1      }
*** WARNING C280 IN LINE 189 OF main.c: 'x': unreferenced local variable
*** WARNING C280 IN LINE 189 OF main.c: 'y': unreferenced local variable
*** WARNING C280 IN LINE 189 OF main.c: 'z': unreferenced local variable
 204          /********************************************************************/
 205          //读卡函数Read_Card()，无形参，有返回值temp
 206          /********************************************************************/
 207          u32 Read_Card(void)
 208          {
 209   1        u8 i=0;                   //起始位循环控制变量
 210   1        u8 timeout;               //超时计数变量
 211   1        u8 timeout_flag;          //超时标志
 212   1        u8 row,col;               //行列变量
 213   1        u8 row_parity;            //行校验变量
 214   1        u8 col_parity[5];         //列校验变量
 215   1        u8 M_data;                //数据位变量
 216   1        u32 temp;                 //卡号变量
 217   1        u32 search=0;             //搜索次数变量
 218   1        while(1)                  //进行完整的读卡过程
 219   1        {   
 220   2          //***************************************************
 221   2          if(search==10)          //若10次搜索都未发现有效数据帧
 222   2            return 0;             //则返回0
 223   2          else                    //否则
 224   2          search++;               //搜索次数值自增
 225   2          timeout=0;              //超时值清零
 226   2          //***************************************************
 227   2          while(Mcode==0)         //等待接收引脚出现低电平
 228   2          {
 229   3            if(timeout==TIME_OUT) //若超时值等于设定阈值
 230   3              break;              //直接跳出本次搜索
 231   3            else                  //若超时值小于设定阈值
 232   3              timeout++;          //超时值自增
 233   3          }
 234   2          //***************************************************
 235   2          if(timeout==100)        //若超时值等于100
 236   2            continue;             //结束本次搜索
 237   2          else                    //否则
C51 COMPILER V9.60.0.0   MAIN                                                              05/25/2025 18:28:08 PAGE 5   

 238   2            timeout=0;            //超时值清零
 239   2          //***************************************************
 240   2          delay384us();           //延时384us
 241   2          if(Mcode)               //开始寻找帧头起始位
 242   2          {  
 243   3            for(i=0;i<8;i++)      //循环8次判断和处理过程
 244   3            {   
 245   4              timeout=0;          //先把超时值清零
 246   4              while(Mcode)        //等待接收引脚为高电平
 247   4              { 
 248   5                if(timeout==TIME_OUT)   //若超时值等于设定阈值
 249   5                {   
 250   6                  timeout_flag=1;break; //判定为超时事件，直接退出
 251   6                }
 252   5                else timeout++;   //否则超时值自增
 253   5              }  
 254   4              delay384us();       //再延时384us，判断下一个位
 255   4              if(Mcode&&timeout_flag==0);
 256   4              //判断下一位是否为1且超时标指是否为0
 257   4              else                //两个条件中若有其一不满足
 258   4                break;            //则直接退出         
 259   4            }
 260   3            //***************************************************
 261   3            if(timeout_flag)      //若超时标志为1
 262   3            {   
 263   4              timeout_flag=0;continue;//则清零标志并退出本次循环
 264   4            }
 265   3            else;
 266   3            //***************************************************
 267   3            if(i==8)//若i=8，则说明帧头已被识别，现在开始接受数据
 268   3            { 
 269   4              timeout_flag=0;     //清零超时标志
 270   4              timeout=0;          //清零超时值
 271   4              while(Mcode)        //等待接收引脚为高电平
 272   4              {  
 273   5                if(timeout==TIME_OUT)   //若超时值等于设定阈值
 274   5                { 
 275   6                  timeout_flag=0;break; //判定为超时事件，直接退出
 276   6                }
 277   5                else timeout++;   //否则超时值自增
 278   5              }   
 279   4              if(timeout_flag)    //若超时标志为1 
 280   4              {
 281   5                timeout_flag=0;continue;//则清零标志并退出本次循环
 282   5              }
 283   4              else; 
 284   4              //***************************************************
 285   4              //将5个列校验值清零
 286   4              col_parity[0]=col_parity[1]=col_parity[2]=0;
 287   4              col_parity[3]=col_parity[4]=0;
 288   4              for(row=0;row<11;row++)
 289   4              //循环11次，接收11行数据（4个数据位+1个行校验值）
 290   4              {
 291   5                for(col=0,row_parity=0;col<5;col++)//接收数据每5个为一行
 292   5                {
 293   6                  delay384us();       //延时384us，判断下一个数据位
 294   6                  if(Mcode)
 295   6                    M_data=1;         //若接收引脚高电平，则数据位为1
 296   6                  else
 297   6                    M_data=0;         //否则，数据位为0
 298   6                  //***************************************************
 299   6                  if(col<4&&row<10)   //若接收数据位在0-3列且在1-10行内
C51 COMPILER V9.60.0.0   MAIN                                                              05/25/2025 18:28:08 PAGE 6   

 300   6                  //意思就是在有效数据区域内
 301   6                  {
 302   7                    temp<<=1;         //卡号变量左移1位
 303   7                    temp+=(u32)M_data;//把新的数据位加到卡号变量中
 304   7                  }
 305   6                  else;
 306   6                  //***************************************************
 307   6                  row_parity+=M_data; //将数据加到行校验变量
 308   6                  col_parity[col]+=M_data;//将数据加到列校验变量
 309   6                  //虽然第5列数据仅作校验，但也加上
 310   6                  timeout=0;          //清零超时值
 311   6                  while(Mcode==(bit)M_data) //等待接收引脚状态为停止位
 312   6                  {
 313   7                    if(timeout==TIME_OUT)   //若超时值等于设定阈值
 314   7                    { 
 315   8                      timeout_flag=1;break; //判定为超时事件，直接退出
 316   8                    }
 317   7                    else timeout++;   //否则超时值自增
 318   7                  }
 319   6                  if(timeout_flag)    //若超时标志为1 
 320   6                    break;            //则退出本次循环
 321   6                  else;
 322   6                }
 323   5                //***************************************************
 324   5                if(row<10)            //因为最后一行没有校验
 325   5                                      //所以要加限制
 326   5                {
 327   6                  if((row_parity&0x01)||timeout_flag)
 328   6                  //若校验出错或超时标识为1
 329   6                  {
 330   7                    temp=0;           //清零本次采集的卡号数据
 331   7                    timeout_flag=1;   //置位超时标志位
 332   7                    break;            //退出
 333   7                  }
 334   6                  else;
 335   6                }
 336   5                else;
 337   5              }
 338   4              //***************************************************
 339   4              //对最后接收的列校验进行判断并结束本次主循环
 340   4              if(timeout_flag||((col_parity[0]&0x01)&&\
 341   4                (col_parity[1]&0x01)&&(col_parity[2]&0x01)&&\
 342   4              (col_parity[3]&0x01)))
 343   4              {                 //最后一列是没有校验的                         
 344   5                timeout_flag=0; //清零超时标志位
 345   5                temp=0;         //清零本次采集的卡号数据
 346   5                continue;       //退出本次循环
 347   5              } 
 348   4              else
 349   4                return temp;    //将卡号数据返回
 350   4            }
 351   3            continue;           //退出本次循环
 352   3          }
 353   2          continue;             //退出本次循环
 354   2        }
 355   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    823    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
C51 COMPILER V9.60.0.0   MAIN                                                              05/25/2025 18:28:08 PAGE 7   

   PDATA SIZE       =   ----    ----
   DATA SIZE        =     34      21
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  3 WARNING(S),  0 ERROR(S)
