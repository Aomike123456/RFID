/******************************************************************
 * 实验名称：ID卡号识别与模拟门禁实验
 * 可配书籍：上册-《深入浅出STC8增强型51单片机进阶攻略》已经出版
						 下册-《深入浅出STC8增强型51单片机实战攻略》还在写作
 * 书籍备注：龙顺宇编著 清华大学出版社出版
 * 淘宝店铺：https://520mcu.taobao.com/
 * 实验平台：思修电子工作室SX-RFID-B低频ID识别与应用开发板 Long
 * 芯片型号：STC8G1K08/17（微调后可移植至STC8A/F/C/G/H系列单片机）
 * 时钟说明：芯片内部12MHz，在使用STC-ISP软件时需要先配置然后下载
 *           到单片机使得时钟配置生效。
 * 实验说明：断电前提下向开发板插入1602液晶模块，然后用USB线插入到
 Uart-USB接口给开发板供电，做好STC-ISP配置并下载程序，观察1602液晶
 上的显示情况（第一行显示“IDT：”，第二行显示“Num：”），“IDT”是卡片
 类型，有管理卡和用户卡两种（可以开锁），除此之外都是非法卡（不能
 开锁），“Num”是卡片的实际卡号，我们在开发板上方5-15cm处放置卡片即
 可识别卡片类型并验证开锁效果，以此模拟门禁场景，学习卡号识别、身份
 验证等功能实现。
******************************************************************/
#include	"STC8G.h"				//主控芯片的头文件
#include  "intrins.h"			//因为要用到nop()函数故而包含此文件
/************************常用数据类型定义*************************/
#define u8  uint8_t
#define u16 uint16_t
#define u32 uint32_t
typedef unsigned char    uint8_t;
typedef unsigned int     uint16_t;
typedef unsigned long    uint32_t;
/************************端口/引脚定义区域************************/
sbit Mcode=P3^2;  				//曼彻斯特码输入端
sbit RLY=P5^5;            //继电器控制引脚
sbit ROTP=P1^7;						//OTP语音芯片复位脚
sbit DATA=P1^5;						//OTP语音芯片数据脚
sbit BUSY=P1^4;						//OTP语音芯片判忙脚
sbit LCDRS=P3^6;    			//LCD1602数据/命令选择端口
sbit LCDEN=P3^7;     			//LCD1602使能信号端口
#define LCDDATA  P1  			//LCD1602数据端口（仅用DB4至DB7）
/************************用户自定义数据区域***********************/
#define TIME_OUT  256			//最大超时阈值
u8 table1[]="IDT:            ";//LCD1602显示卡片类型
u8 table2[]="Num:            ";//LCD1602显示卡片卡号
#define ID1 319631138UL		//管理卡（可按需设定和修改）
#define ID2 319635063UL		//用户卡（可按需设定和修改）
/*1:不放内容，2:滴（音效），3:错误提示音（音效），4:欢迎使用思修
电子射频识别开发板，5:模拟门禁模式，6:模拟公交模式，7:刷卡成功，
8:十位卡号为，9:八位卡号为，10:0，11:1，12:2，13:3，14:4，15:5，
16:6，17:7，18:8，19:9，20:管理卡，21:用户卡，22:学生卡，23:老年
卡，24:卡片有效，解锁成功，25:卡片非法，解锁失败，26:按键，27:识
别成功，28:扣费成功，29:免费乘车*/
/**************************函数声明区域***************************/
void delay(u16 Count);		//延时函数
void Delay150us(void);		//150us延时函数
void delay384us(void);		//384us延时函数
void IO_init(void);   		//IO初始化函数
void SYSCLK_CCO(u8 TYPE,u8 SET_F,u8 SET_P);//系统时钟输出函数
void LCD1602_Write(u8 cmdordata,u8 writetype);
//写入液晶模组命令或数据函数
void LCD1602_init(void);	//LCD1602初始化函数
void LCD1602_DIS(void);		//显示字符函数
void LCD1602_DIS_CHAR(u8 x,u8 y,u8 z);//在设定地址写入字符数据函数
void TTS(u8 num);					//OTP语音合成函数
u32 Read_Card(void);			//读卡函数
/***************************主函数区域****************************/
void main(void)
{
 	u32 SN=0;								//定义卡号接收变量
	static u8 bit10_0,bit10_1,bit10_2,bit10_3,bit10_4,bit10_5,\
	bit10_6,bit10_7,bit10_8,bit10_9;//定义10位卡号的每一位
	IO_init();							//IO初始化
	SYSCLK_CCO(1,96,1);			//P1.6输出96分频的内部高速时钟12M/96=125kHz
	LCDEN=1;delay(200);			//使能置“1”（防止复位乱码）
	LCDEN=0;delay(200);			//使能清“0”（防止复位乱码）
	LCD1602_init(); 				//LCD1602初始化
	delay(200);							//延时等待稳定
  LCD1602_DIS();  				//显示字符效果
	TTS(1);while(!BUSY);		//播报1段并等待完成（无内容）
	TTS(5);while(!BUSY);		//播报5段并等待完成（模拟门禁模式）
	while(1)
	{
		SN=Read_Card();				//读取卡号数据
		if(SN)								//若卡号不为0，即有效卡号
		{
			//完成10位卡号的取位
			bit10_0=SN/1000000000;								//取出10位卡号第1位
			bit10_1=SN%1000000000/100000000;			//取出10位卡号第2位
			bit10_2=SN%100000000/10000000;				//取出10位卡号第3位
			bit10_3=SN%10000000/1000000;					//取出10位卡号第4位
			bit10_4=SN%1000000/100000;						//取出10位卡号第5位
			bit10_5=SN%100000/10000;							//取出10位卡号第6位
			bit10_6=SN%10000/1000;								//取出10位卡号第7位
			bit10_7=SN%1000/100;									//取出10位卡号第8位
			bit10_8=SN%100/10;										//取出10位卡号第9位
			bit10_9=SN%10;												//取出10位卡号第10位
			//显示10位卡号
			LCD1602_DIS_CHAR(2,5, bit10_0+0x30);	//显示10位卡号第1位
			LCD1602_DIS_CHAR(2,6, bit10_1+0x30);	//显示10位卡号第2位
			LCD1602_DIS_CHAR(2,7, bit10_2+0x30);	//显示10位卡号第3位
			LCD1602_DIS_CHAR(2,8, bit10_3+0x30);	//显示10位卡号第4位
			LCD1602_DIS_CHAR(2,9, bit10_4+0x30);	//显示10位卡号第5位
			LCD1602_DIS_CHAR(2,10,bit10_5+0x30);	//显示10位卡号第6位
			LCD1602_DIS_CHAR(2,11,bit10_6+0x30);	//显示10位卡号第7位
			LCD1602_DIS_CHAR(2,12,bit10_7+0x30);	//显示10位卡号第8位
			LCD1602_DIS_CHAR(2,13,bit10_8+0x30);	//显示10位卡号第9位
			LCD1602_DIS_CHAR(2,14,bit10_9+0x30);	//显示10位卡号第10位
			switch(SN)									//播报并显示卡片类型
			{
				case ID1:
				{
					//显示卡片类型为“Admin”
					LCD1602_DIS_CHAR(1,5, 'A');
					LCD1602_DIS_CHAR(1,6, 'd');
					LCD1602_DIS_CHAR(1,7, 'm');
					LCD1602_DIS_CHAR(1,8, 'i');
					LCD1602_DIS_CHAR(1,9, 'n');
					RLY=1;									//继电器吸合
					TTS(1);while(!BUSY);		//播报1段并等待完成（无内容）
					TTS(2);while(!BUSY);		//播报2段并等待完成（滴）
					TTS(20);while(!BUSY);		//播报20段并等待完成（管理卡）
					TTS(24);while(!BUSY);		//播报24段并等待完成（卡片有效，解锁成功）
				}break;
				case ID2:
				{
					//显示卡片类型为“User”
					LCD1602_DIS_CHAR(1,5, 'U');
					LCD1602_DIS_CHAR(1,6, 's');
					LCD1602_DIS_CHAR(1,7, 'e');
					LCD1602_DIS_CHAR(1,8, 'r');
					LCD1602_DIS_CHAR(1,9, ' ');
					RLY=1;									//继电器吸合
					TTS(1);while(!BUSY);		//播报1段并等待完成（无内容）
					TTS(2);while(!BUSY);		//播报2段并等待完成（滴）
					TTS(21);while(!BUSY);		//播报21段并等待完成（用户卡）
					TTS(24);while(!BUSY);		//播报24段并等待完成（卡片有效，解锁成功）
				}break;
				default:
				{
					//显示卡片类型为“Error”
					LCD1602_DIS_CHAR(1,5, 'E');
					LCD1602_DIS_CHAR(1,6, 'r');
					LCD1602_DIS_CHAR(1,7, 'r');
					LCD1602_DIS_CHAR(1,8, 'o');
					LCD1602_DIS_CHAR(1,9, 'r');
					RLY=0;									//继电器关闭
					TTS(1);while(!BUSY);		//播报1段并等待完成（无内容）
					TTS(3);while(!BUSY);		//播报3段并等待完成（错误提示音）
					TTS(25);while(!BUSY);		//播报25段并等待完成（卡片非法，解锁失败）					
				}break;
			}
			SN=0;//清零卡号
		}
	}
}
/****************************************************************/
//延时函数delay()，有形参Count用于控制延时函数执行次数，无返回值
/****************************************************************/
void delay(u16 Count)
{
  u8 i,j;
  while (Count--)
  {
    for(i=0;i<50;i++)
      for(j=0;j<20;j++);
  }
}
/********************************************************************/
//150us延时函数Delay150us()，无形参，无返回值，这是用STC-ISP算出
//来的150us延时，此延时可以不严格，但应大于50us小于200us
/********************************************************************/
void Delay150us(void)//@12MHz
{
	u8 i, j;
	_nop_();
	_nop_();
	i=3;
	j=83;
	do
	{
		while(--j);
	} while(--i);
}
/****************************************************************/
//384us延时函数delay384us()，无形参，无返回值，这是用STC-ISP算出
//来的384us延时，此延时可以不严格，但应大于256us小于512us
/****************************************************************/
void delay384us(void)//@12MHz
{
	u8 i, j;
	_nop_();
	_nop_();
	i=6;
	j=249;
	do
	{
		while(--j);
	} while(--i);
}
/****************************************************************/
//IO初始化函数IO_Init()，无形参，无返回值
/****************************************************************/
void IO_init(void)
{
	//配置P1.6为推挽/强上拉模式
	P1M0|=0x40;			//P1M0.6=1
	P1M1&=0xBF;			//P1M1.6=0
	//配置P5.5为推挽/强上拉模式
	P5M0|=0x20;			//P5M0.5=1
	P5M1&=0xDF;			//P5M1.5=0
	//配置P3.2为准双向/弱上拉模式
	P3M0&=0xFB;			//P3M0.2=0
	P3M1&=0xFB;			//P3M1.2=0
	//配置P3.6-7为准双向/弱上拉模式
	P3M0&=0x3F;			//P3M0.6-7=0
	P3M1&=0x3F;			//P3M1.6-7=0
	//配置P1.0-3为准双向/弱上拉模式
	P1M0&=0xF0;			//P1M0.0-3=0
	P1M1&=0xF0;			//P1M1.0-3=0
	//配置P1.4为准双向/弱上拉模式
	P1M0&=0xEF;			//P1M0.4=0
	P1M1&=0xEF;			//P1M1.4=0
	//配置P1.5为推挽输出模式
	P1M0|=0x20;			//P1M0.5=1
	P1M1&=0xDF;			//P1M1.5=0
	//配置P1.7为推挽输出模式
	P1M0|=0x80;			//P1M0.7=1
	P1M1&=0x7F;			//P1M1.7=0
	delay(10);			//等待I/O模式配置稳定
	RLY=0;					//继电器关闭
	ROTP=1;					//拉高复位引脚
	DATA=1;					//拉高数据引脚
}
/********************************************************************/
//系统时钟输出函数SYSCLK_CCO()，有形参TYPE用于选择时钟源（0-外部时钟）
//（1-片内高速时钟）（2-片内低速时钟），有形参SET_F用于指定时钟源
//分频系数，有形参SET_P用于指定输出引脚的选择（P5.4/P1.6）无返回值
/********************************************************************/
void SYSCLK_CCO(u8 TYPE,u8 SET_F,u8 SET_P)
{
	P_SW2|=0x80;					//允许访问扩展特殊功能寄存器XSFR
	switch(TYPE)
	{
		case 0:
		{
			XOSCCR|=0xC0;			//使能外部晶体振荡器
			while(!(XOSCCR&0x01));//等待外部时钟稳定
			//配置MCKSEL[1:0]=“01”，选择外部时钟
			CLKSEL&=0xFD;			//清零MCKSEL[1:0]的高位
			CLKSEL|=0x01;			//配置MCKSEL[1:0]的低位
		}break;		
		case 1:							//若选择片内高速时钟，则无需配置时钟选择
		{}break;
		case 2:
		{
			IRC32KCR|=0x80;		//使能内部32kHz低速IRC控制寄存器
			while(!(IRC32KCR&0x01));//等待内部低速时钟稳定
			CLKSEL|=0x03;			//配置MCKSEL[1:0]=“11”选择内部低速IRC时钟
		}break;
	}
	switch(SET_F)
	{
		case 1:{MCLKOCR&=0x80;MCLKOCR|=0x01;}break;		//Fsysclk/1
		case 2:{MCLKOCR&=0x80;MCLKOCR|=0x02;}break;		//Fsysclk/2
		case 4:{MCLKOCR&=0x80;MCLKOCR|=0x04;}break;		//Fsysclk/4
		case 8:{MCLKOCR&=0x80;MCLKOCR|=0x08;}break;		//Fsysclk/8
		case 16:{MCLKOCR&=0x80;MCLKOCR|=0x10;}break;	//Fsysclk/16
		case 32:{MCLKOCR&=0x80;MCLKOCR|=0x20;}break;	//Fsysclk/32
		case 64:{MCLKOCR&=0x80;MCLKOCR|=0x40;}break;	//Fsysclk/64
		case 96:{MCLKOCR&=0x80;MCLKOCR|=0x60;}break;	//Fsysclk/96
		case 127:{MCLKOCR&=0x80;MCLKOCR|=0x7F;}break;	//Fsysclk/127
	}
	if(SET_P==0)
		MCLKOCR&=0x7F;			//配置时钟由P5.4引脚输出
	else
		MCLKOCR|=0x80;			//配置时钟由P1.6引脚输出
	P_SW2&=0x7F; 					//结束并关闭XSFR访问
}
/********************************************************************/
//LCD1602初始化函数LCD1602_init()，无形参和返回值
/********************************************************************/
void LCD1602_init(void)
{
	LCD1602_Write(0x28,0);delay(10);//数据总线为4位，显示2行，5*7点阵/每字符
	LCDEN=1;delay(10);//使能置“1”
	LCDEN=0;delay(10);//使能清“0”
	LCD1602_Write(0x0C,0);delay(10);//设置开显示，不显示光标
	LCD1602_Write(0x06,0);delay(10);//写入新数据后显示屏整体不移动仅光标右移
	LCD1602_Write(0x01,0);delay(10);//写入清屏命令
}
/********************************************************************/
//显示字符函数LCD1602_DIS()，无形参和返回值
/********************************************************************/
void LCD1602_DIS(void)
{
  u8 i;									//定义控制循环变量i
  LCD1602_Write(0x80,0);//选择第一行
	delay(5);							//延时等待1602稳定
  for(i=0;i<16;i++)
  {
      LCD1602_Write(table1[i],1);//写入table1[]内容
      delay(1);
  }
  LCD1602_Write(0xC0,0);//选择第二行
	delay(5);							//延时等待1602稳定
  for(i=0;i<16;i++)
  {
      LCD1602_Write(table2[i],1);//写入table2[]内容
      delay(1);
  }
}
/********************************************************************/
//写入液晶模组命令或数据函数LCD1602_Write()，有形参cmdordata
//和writetype，无返回值
/********************************************************************/
void LCD1602_Write(u8 cmdordata,u8 writetype)
{
	u8 temp=0;								//定义数据处理中间变量
	LCDRS=writetype;					//判断写入类型0为命令1为数据
	delay(2);									//延时等待稳定
	LCDDATA&=0xF0;						//清数据引脚
	temp=cmdordata>>4;				//高四位移到低四位
	LCDDATA|=temp&0x0F;				//写高四位
	LCDEN=1;delay(2);					//使能置“1”
	LCDEN=0;delay(2);					//使能清“0”
	LCDDATA&=0xF0;						//清数据引脚
	LCDDATA|=cmdordata&0x0F;	//写低四位
	LCDEN=1;delay(2);					//使能置“1”
	LCDEN=0;delay(2);					//使能清“0”
}
/********************************************************************/
//设定地址写入字符函数LCD1602_DIS_CHAR()，有形参x、y、z无返回值
//x表示1602液晶的行，y表示列地址，z表示欲写入的字符
/********************************************************************/
void LCD1602_DIS_CHAR(u8 x,u8 y,u8 z)
{
  u8 address;
  if(x==1)						//若欲显示在第一行
    address=0x80+y;		//第一行的行首地址+列地址
  else
    address=0xC0+y;		//第二行的行首地址+列地址
  LCD1602_Write(address,0);		//设定显示地址
  LCD1602_Write(z,1);	//写入字符数据
}
/********************************************************************/
//OTP语音合成函数TTS_Prosser(),无形参，无返回值
/********************************************************************/
void TTS(u8 num)
{
	ROTP=1;					//拉高复位引脚
	Delay150us();		//保持150us
	ROTP=0;					//拉低复位引脚
	Delay150us();		//保持150us
	ROTP=1;					//拉高复位引脚
	Delay150us();		//保持150us
	ROTP=0;					//拉低复位引脚
	Delay150us();		//保持150us
	while(num>0)		//若选定播放段地址不为0，则正常播报
	{
		DATA=1;				//拉高数据引脚
		Delay150us();	//保持150us
		DATA=0;				//拉高数据引脚
		Delay150us();	//保持150us
		num--;				//发出num个脉冲指定要播报的段
	}
}
/********************************************************************/
//读卡函数Read_Card()，无形参，有返回值temp
/********************************************************************/
u32 Read_Card(void)
{
	u8 i=0;										//起始位循环控制变量
	u8 timeout;  							//超时计数变量
	u8 timeout_flag; 					//超时标志
	u8 row,col;	  						//行列变量
	u8 row_parity;  					//行校验变量
	u8 col_parity[5];					//列校验变量
	u8 M_data;								//数据位变量
	u32 temp;									//卡号变量
	u32 search=0;							//搜索次数变量
	while(1)									//进行完整的读卡过程
	{		
		//***************************************************
		if(search==10)					//若10次搜索都未发现有效数据帧
			return 0;							//则返回0
		else										//否则
		search++;								//搜索次数值自增
		timeout=0;							//超时值清零
		//***************************************************
		while(Mcode==0)					//等待接收引脚出现低电平
		{
			if(timeout==TIME_OUT)	//若超时值等于设定阈值
				break;							//直接跳出本次搜索
			else									//若超时值小于设定阈值
				timeout++;					//超时值自增
		}
		//***************************************************
		if(timeout==100)				//若超时值等于100
			continue;							//结束本次搜索
		else										//否则
			timeout=0;						//超时值清零
		//***************************************************
		delay384us();	  				//延时384us
		if(Mcode)								//开始寻找帧头起始位
		{	 
			for(i=0;i<8;i++)			//循环8次判断和处理过程
			{	  
				timeout=0;					//先把超时值清零
				while(Mcode)				//等待接收引脚为高电平
				{	
					if(timeout==TIME_OUT)		//若超时值等于设定阈值
					{	  
						timeout_flag=1;break;	//判定为超时事件，直接退出
					}
					else timeout++;		//否则超时值自增
				}	 
				delay384us();				//再延时384us，判断下一个位
				if(Mcode&&timeout_flag==0);
				//判断下一位是否为1且超时标指是否为0
				else 								//两个条件中若有其一不满足
					break;						//则直接退出			   
			}
			//***************************************************
			if(timeout_flag)			//若超时标志为1
			{	  
				timeout_flag=0;continue;//则清零标志并退出本次循环
			}
			else;
			//***************************************************
			if(i==8)//若i=8，则说明帧头已被识别，现在开始接受数据
			{	
				timeout_flag=0;			//清零超时标志
				timeout=0;					//清零超时值
				while(Mcode)				//等待接收引脚为高电平
				{  
					if(timeout==TIME_OUT)		//若超时值等于设定阈值
					{	
						timeout_flag=0;break;	//判定为超时事件，直接退出
					}
					else timeout++;		//否则超时值自增
				}	  
				if(timeout_flag)	  //若超时标志为1 
				{
					timeout_flag=0;continue;//则清零标志并退出本次循环
				}
				else; 
				//***************************************************
				//将5个列校验值清零
				col_parity[0]=col_parity[1]=col_parity[2]=0;
				col_parity[3]=col_parity[4]=0;
				for(row=0;row<11;row++)
				//循环11次，接收11行数据（4个数据位+1个行校验值）
				{
					for(col=0,row_parity=0;col<5;col++)//接收数据每5个为一行
					{
						delay384us();  			//延时384us，判断下一个数据位
						if(Mcode)
							M_data=1;					//若接收引脚高电平，则数据位为1
						else
							M_data=0;					//否则，数据位为0
						//***************************************************
						if(col<4&&row<10)		//若接收数据位在0-3列且在1-10行内
						//意思就是在有效数据区域内
						{
							temp<<=1;					//卡号变量左移1位
							temp+=(u32)M_data;//把新的数据位加到卡号变量中
						}
						else;
						//***************************************************
						row_parity+=M_data;	//将数据加到行校验变量
						col_parity[col]+=M_data;//将数据加到列校验变量
						//虽然第5列数据仅作校验，但也加上
						timeout=0;					//清零超时值
						while(Mcode==(bit)M_data)	//等待接收引脚状态为停止位
						{
							if(timeout==TIME_OUT)		//若超时值等于设定阈值
							{	
								timeout_flag=1;break;	//判定为超时事件，直接退出
							}
							else timeout++;		//否则超时值自增
						}
						if(timeout_flag)		//若超时标志为1 
							break;						//则退出本次循环
						else;
					}
					//***************************************************
					if(row<10)						//因为最后一行没有校验
																//所以要加限制
					{
						if((row_parity&0x01)||timeout_flag)
						//若校验出错或超时标识为1
						{
							temp=0;						//清零本次采集的卡号数据
							timeout_flag=1;		//置位超时标志位
							break;						//退出
						}
						else;
					}
					else;
				}
				//***************************************************
				//对最后接收的列校验进行判断并结束本次主循环
				if(timeout_flag||((col_parity[0]&0x01)&&\
					(col_parity[1]&0x01)&&(col_parity[2]&0x01)&&\
				(col_parity[3]&0x01)))
				{									//最后一列是没有校验的												 
					timeout_flag=0;	//清零超时标志位
					temp=0;					//清零本次采集的卡号数据
					continue;				//退出本次循环
				} 
				else
					return temp;		//将卡号数据返回
			}
			continue;						//退出本次循环
		}
		continue;							//退出本次循环
	}
}