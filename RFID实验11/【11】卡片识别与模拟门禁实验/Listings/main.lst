C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:43:12 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /******************************************************************
   2           * 实验名称：ID卡号识别与模拟门禁实验
   3           * 可配书籍：上册-《深入浅出STC8增强型51单片机进阶攻略》已经出版
   4                       下册-《深入浅出STC8增强型51单片机实战攻略》还在写作
   5           * 书籍备注：龙顺宇编著 清华大学出版社出版
   6           * 淘宝店铺：https://520mcu.taobao.com/
   7           * 实验平台：思修电子工作室SX-RFID-B低频ID识别与应用开发板 Long
   8           * 芯片型号：STC8G1K08/17（微调后可移植至STC8A/F/C/G/H系列单片机）
   9           * 时钟说明：芯片内部12MHz，在使用STC-ISP软件时需要先配置然后下载
  10           *           到单片机使得时钟配置生效。
  11           * 实验说明：断电前提下向开发板插入1602液晶模块，然后用USB线插入到
  12           Uart-USB接口给开发板供电，做好STC-ISP配置并下载程序，观察1602液晶
  13           上的显示情况（第一行显示“IDT：”，第二行显示“Num：”），“IDT”是卡片
  14           类型，有管理卡和用户卡两种（可以开锁），除此之外都是非法卡（不能
  15           开锁），“Num”是卡片的实际卡号，我们在开发板上方5-15cm处放置卡片即
  16           可识别卡片类型并验证开锁效果，以此模拟门禁场景，学习卡号识别、身份
  17           验证等功能实现。
  18          ******************************************************************/
  19          #include  "STC8G.h"       //主控芯片的头文件
  20          #include  "intrins.h"     //因为要用到nop()函数故而包含此文件
  21          /************************常用数据类型定义*************************/
  22          #define u8  uint8_t
  23          #define u16 uint16_t
  24          #define u32 uint32_t
  25          typedef unsigned char    uint8_t;
  26          typedef unsigned int     uint16_t;
  27          typedef unsigned long    uint32_t;
  28          /************************端口/引脚定义区域************************/
  29          sbit Mcode=P3^2;          //曼彻斯特码输入端
  30          sbit RLY=P5^5;            //继电器控制引脚
  31          sbit ROTP=P1^7;           //OTP语音芯片复位脚
  32          sbit DATA=P1^5;           //OTP语音芯片数据脚
  33          sbit BUSY=P1^4;           //OTP语音芯片判忙脚
  34          sbit LCDRS=P3^6;          //LCD1602数据/命令选择端口
  35          sbit LCDEN=P3^7;          //LCD1602使能信号端口
  36          #define LCDDATA  P1       //LCD1602数据端口（仅用DB4至DB7）
  37          /************************用户自定义数据区域***********************/
  38          #define TIME_OUT  256     //最大超时阈值
  39          u8 table1[]="IDT:            ";//LCD1602显示卡片类型
  40          u8 table2[]="Num:            ";//LCD1602显示卡片卡号
  41          #define ID1 319631138UL   //管理卡（可按需设定和修改）
  42          #define ID2 319635063UL   //用户卡（可按需设定和修改）
  43          /*1:不放内容，2:滴（音效），3:错误提示音（音效），4:欢迎使用思修
  44          电子射频识别开发板，5:模拟门禁模式，6:模拟公交模式，7:刷卡成功，
  45          8:十位卡号为，9:八位卡号为，10:0，11:1，12:2，13:3，14:4，15:5，
  46          16:6，17:7，18:8，19:9，20:管理卡，21:用户卡，22:学生卡，23:老年
  47          卡，24:卡片有效，解锁成功，25:卡片非法，解锁失败，26:按键，27:识
  48          别成功，28:扣费成功，29:免费乘车*/
  49          /**************************函数声明区域***************************/
  50          void delay(u16 Count);    //延时函数
  51          void Delay150us(void);    //150us延时函数
  52          void delay384us(void);    //384us延时函数
  53          void IO_init(void);       //IO初始化函数
  54          void SYSCLK_CCO(u8 TYPE,u8 SET_F,u8 SET_P);//系统时钟输出函数
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:43:12 PAGE 2   

  55          void LCD1602_Write(u8 cmdordata,u8 writetype);
  56          //写入液晶模组命令或数据函数
  57          void LCD1602_init(void);  //LCD1602初始化函数
  58          void LCD1602_DIS(void);   //显示字符函数
  59          void LCD1602_DIS_CHAR(u8 x,u8 y,u8 z);//在设定地址写入字符数据函数
  60          void TTS(u8 num);         //OTP语音合成函数
  61          u32 Read_Card(void);      //读卡函数
  62          /***************************主函数区域****************************/
  63          void main(void)
  64          {
  65   1        u32 SN=0;               //定义卡号接收变量
  66   1        static u8 bit10_0,bit10_1,bit10_2,bit10_3,bit10_4,bit10_5,\
  67   1        bit10_6,bit10_7,bit10_8,bit10_9;//定义10位卡号的每一位
  68   1        IO_init();              //IO初始化
  69   1        SYSCLK_CCO(1,96,1);     //P1.6输出96分频的内部高速时钟12M/96=125kHz
  70   1        LCDEN=1;delay(200);     //使能置“1”（防止复位乱码）
  71   1        LCDEN=0;delay(200);     //使能清“0”（防止复位乱码）
  72   1        LCD1602_init();         //LCD1602初始化
  73   1        delay(200);             //延时等待稳定
  74   1        LCD1602_DIS();          //显示字符效果
  75   1        TTS(1);while(!BUSY);    //播报1段并等待完成（无内容）
  76   1        TTS(5);while(!BUSY);    //播报5段并等待完成（模拟门禁模式）
  77   1        while(1)
  78   1        {
  79   2          SN=Read_Card();       //读取卡号数据
  80   2          if(SN)                //若卡号不为0，即有效卡号
  81   2          {
  82   3            //完成10位卡号的取位
  83   3            bit10_0=SN/1000000000;                //取出10位卡号第1位
  84   3            bit10_1=SN%1000000000/100000000;      //取出10位卡号第2位
  85   3            bit10_2=SN%100000000/10000000;        //取出10位卡号第3位
  86   3            bit10_3=SN%10000000/1000000;          //取出10位卡号第4位
  87   3            bit10_4=SN%1000000/100000;            //取出10位卡号第5位
  88   3            bit10_5=SN%100000/10000;              //取出10位卡号第6位
  89   3            bit10_6=SN%10000/1000;                //取出10位卡号第7位
  90   3            bit10_7=SN%1000/100;                  //取出10位卡号第8位
  91   3            bit10_8=SN%100/10;                    //取出10位卡号第9位
  92   3            bit10_9=SN%10;                        //取出10位卡号第10位
  93   3            //显示10位卡号
  94   3            LCD1602_DIS_CHAR(2,5, bit10_0+0x30);  //显示10位卡号第1位
  95   3            LCD1602_DIS_CHAR(2,6, bit10_1+0x30);  //显示10位卡号第2位
  96   3            LCD1602_DIS_CHAR(2,7, bit10_2+0x30);  //显示10位卡号第3位
  97   3            LCD1602_DIS_CHAR(2,8, bit10_3+0x30);  //显示10位卡号第4位
  98   3            LCD1602_DIS_CHAR(2,9, bit10_4+0x30);  //显示10位卡号第5位
  99   3            LCD1602_DIS_CHAR(2,10,bit10_5+0x30);  //显示10位卡号第6位
 100   3            LCD1602_DIS_CHAR(2,11,bit10_6+0x30);  //显示10位卡号第7位
 101   3            LCD1602_DIS_CHAR(2,12,bit10_7+0x30);  //显示10位卡号第8位
 102   3            LCD1602_DIS_CHAR(2,13,bit10_8+0x30);  //显示10位卡号第9位
 103   3            LCD1602_DIS_CHAR(2,14,bit10_9+0x30);  //显示10位卡号第10位
 104   3            switch(SN)                  //播报并显示卡片类型
 105   3            {
 106   4              case ID1:
 107   4              {
 108   5                //显示卡片类型为“Admin”
 109   5                LCD1602_DIS_CHAR(1,5, 'A');
 110   5                LCD1602_DIS_CHAR(1,6, 'd');
 111   5                LCD1602_DIS_CHAR(1,7, 'm');
 112   5                LCD1602_DIS_CHAR(1,8, 'i');
 113   5                LCD1602_DIS_CHAR(1,9, 'n');
 114   5                RLY=1;                  //继电器吸合
 115   5                TTS(1);while(!BUSY);    //播报1段并等待完成（无内容）
 116   5                TTS(2);while(!BUSY);    //播报2段并等待完成（滴）
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:43:12 PAGE 3   

 117   5                TTS(20);while(!BUSY);   //播报20段并等待完成（管理卡）
 118   5                TTS(24);while(!BUSY);   //播报24段并等待完成（卡片有效，解锁成功）
 119   5              }break;
 120   4              case ID2:
 121   4              {
 122   5                //显示卡片类型为“User”
 123   5                LCD1602_DIS_CHAR(1,5, 'U');
 124   5                LCD1602_DIS_CHAR(1,6, 's');
 125   5                LCD1602_DIS_CHAR(1,7, 'e');
 126   5                LCD1602_DIS_CHAR(1,8, 'r');
 127   5                LCD1602_DIS_CHAR(1,9, ' ');
 128   5                RLY=1;                  //继电器吸合
 129   5                TTS(1);while(!BUSY);    //播报1段并等待完成（无内容）
 130   5                TTS(2);while(!BUSY);    //播报2段并等待完成（滴）
 131   5                TTS(21);while(!BUSY);   //播报21段并等待完成（用户卡）
 132   5                TTS(24);while(!BUSY);   //播报24段并等待完成（卡片有效，解锁成功）
 133   5              }break;
 134   4              default:
 135   4              {
 136   5                //显示卡片类型为“Error”
 137   5                LCD1602_DIS_CHAR(1,5, 'E');
 138   5                LCD1602_DIS_CHAR(1,6, 'r');
 139   5                LCD1602_DIS_CHAR(1,7, 'r');
 140   5                LCD1602_DIS_CHAR(1,8, 'o');
 141   5                LCD1602_DIS_CHAR(1,9, 'r');
 142   5                RLY=0;                  //继电器关闭
 143   5                TTS(1);while(!BUSY);    //播报1段并等待完成（无内容）
 144   5                TTS(3);while(!BUSY);    //播报3段并等待完成（错误提示音）
 145   5                TTS(25);while(!BUSY);   //播报25段并等待完成（卡片非法，解锁失败）          
 146   5              }break;
 147   4            }
 148   3            SN=0;//清零卡号
 149   3          }
 150   2        }
 151   1      }
 152          /****************************************************************/
 153          //延时函数delay()，有形参Count用于控制延时函数执行次数，无返回值
 154          /****************************************************************/
 155          void delay(u16 Count)
 156          {
 157   1        u8 i,j;
 158   1        while (Count--)
 159   1        {
 160   2          for(i=0;i<50;i++)
 161   2            for(j=0;j<20;j++);
 162   2        }
 163   1      }
 164          /********************************************************************/
 165          //150us延时函数Delay150us()，无形参，无返回值，这是用STC-ISP算出
 166          //来的150us延时，此延时可以不严格，但应大于50us小于200us
 167          /********************************************************************/
 168          void Delay150us(void)//@12MHz
 169          {
 170   1        u8 i, j;
 171   1        _nop_();
 172   1        _nop_();
 173   1        i=3;
 174   1        j=83;
 175   1        do
 176   1        {
 177   2          while(--j);
 178   2        } while(--i);
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:43:12 PAGE 4   

 179   1      }
 180          /****************************************************************/
 181          //384us延时函数delay384us()，无形参，无返回值，这是用STC-ISP算出
 182          //来的384us延时，此延时可以不严格，但应大于256us小于512us
 183          /****************************************************************/
 184          void delay384us(void)//@12MHz
 185          {
 186   1        u8 i, j;
 187   1        _nop_();
 188   1        _nop_();
 189   1        i=6;
 190   1        j=249;
 191   1        do
 192   1        {
 193   2          while(--j);
 194   2        } while(--i);
 195   1      }
 196          /****************************************************************/
 197          //IO初始化函数IO_Init()，无形参，无返回值
 198          /****************************************************************/
 199          void IO_init(void)
 200          {
 201   1        //配置P1.6为推挽/强上拉模式
 202   1        P1M0|=0x40;     //P1M0.6=1
 203   1        P1M1&=0xBF;     //P1M1.6=0
 204   1        //配置P5.5为推挽/强上拉模式
 205   1        P5M0|=0x20;     //P5M0.5=1
 206   1        P5M1&=0xDF;     //P5M1.5=0
 207   1        //配置P3.2为准双向/弱上拉模式
 208   1        P3M0&=0xFB;     //P3M0.2=0
 209   1        P3M1&=0xFB;     //P3M1.2=0
 210   1        //配置P3.6-7为准双向/弱上拉模式
 211   1        P3M0&=0x3F;     //P3M0.6-7=0
 212   1        P3M1&=0x3F;     //P3M1.6-7=0
 213   1        //配置P1.0-3为准双向/弱上拉模式
 214   1        P1M0&=0xF0;     //P1M0.0-3=0
 215   1        P1M1&=0xF0;     //P1M1.0-3=0
 216   1        //配置P1.4为准双向/弱上拉模式
 217   1        P1M0&=0xEF;     //P1M0.4=0
 218   1        P1M1&=0xEF;     //P1M1.4=0
 219   1        //配置P1.5为推挽输出模式
 220   1        P1M0|=0x20;     //P1M0.5=1
 221   1        P1M1&=0xDF;     //P1M1.5=0
 222   1        //配置P1.7为推挽输出模式
 223   1        P1M0|=0x80;     //P1M0.7=1
 224   1        P1M1&=0x7F;     //P1M1.7=0
 225   1        delay(10);      //等待I/O模式配置稳定
 226   1        RLY=0;          //继电器关闭
 227   1        ROTP=1;         //拉高复位引脚
 228   1        DATA=1;         //拉高数据引脚
 229   1      }
 230          /********************************************************************/
 231          //系统时钟输出函数SYSCLK_CCO()，有形参TYPE用于选择时钟源（0-外部时钟）
 232          //（1-片内高速时钟）（2-片内低速时钟），有形参SET_F用于指定时钟源
 233          //分频系数，有形参SET_P用于指定输出引脚的选择（P5.4/P1.6）无返回值
 234          /********************************************************************/
 235          void SYSCLK_CCO(u8 TYPE,u8 SET_F,u8 SET_P)
 236          {
 237   1        P_SW2|=0x80;          //允许访问扩展特殊功能寄存器XSFR
 238   1        switch(TYPE)
 239   1        {
 240   2          case 0:
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:43:12 PAGE 5   

 241   2          {
 242   3            XOSCCR|=0xC0;     //使能外部晶体振荡器
 243   3            while(!(XOSCCR&0x01));//等待外部时钟稳定
 244   3            //配置MCKSEL[1:0]=“01”，选择外部时钟
 245   3            CLKSEL&=0xFD;     //清零MCKSEL[1:0]的高位
 246   3            CLKSEL|=0x01;     //配置MCKSEL[1:0]的低位
 247   3          }break;   
 248   2          case 1:             //若选择片内高速时钟，则无需配置时钟选择
 249   2          {}break;
 250   2          case 2:
 251   2          {
 252   3            IRC32KCR|=0x80;   //使能内部32kHz低速IRC控制寄存器
 253   3            while(!(IRC32KCR&0x01));//等待内部低速时钟稳定
 254   3            CLKSEL|=0x03;     //配置MCKSEL[1:0]=“11”选择内部低速IRC时钟
 255   3          }break;
 256   2        }
 257   1        switch(SET_F)
 258   1        {
 259   2          case 1:{MCLKOCR&=0x80;MCLKOCR|=0x01;}break;   //Fsysclk/1
 260   2          case 2:{MCLKOCR&=0x80;MCLKOCR|=0x02;}break;   //Fsysclk/2
 261   2          case 4:{MCLKOCR&=0x80;MCLKOCR|=0x04;}break;   //Fsysclk/4
 262   2          case 8:{MCLKOCR&=0x80;MCLKOCR|=0x08;}break;   //Fsysclk/8
 263   2          case 16:{MCLKOCR&=0x80;MCLKOCR|=0x10;}break;  //Fsysclk/16
 264   2          case 32:{MCLKOCR&=0x80;MCLKOCR|=0x20;}break;  //Fsysclk/32
 265   2          case 64:{MCLKOCR&=0x80;MCLKOCR|=0x40;}break;  //Fsysclk/64
 266   2          case 96:{MCLKOCR&=0x80;MCLKOCR|=0x60;}break;  //Fsysclk/96
 267   2          case 127:{MCLKOCR&=0x80;MCLKOCR|=0x7F;}break; //Fsysclk/127
 268   2        }
 269   1        if(SET_P==0)
 270   1          MCLKOCR&=0x7F;      //配置时钟由P5.4引脚输出
 271   1        else
 272   1          MCLKOCR|=0x80;      //配置时钟由P1.6引脚输出
 273   1        P_SW2&=0x7F;          //结束并关闭XSFR访问
 274   1      }
 275          /********************************************************************/
 276          //LCD1602初始化函数LCD1602_init()，无形参和返回值
 277          /********************************************************************/
 278          void LCD1602_init(void)
 279          {
 280   1        LCD1602_Write(0x28,0);delay(10);//数据总线为4位，显示2行，5*7点阵/每字符
 281   1        LCDEN=1;delay(10);//使能置“1”
 282   1        LCDEN=0;delay(10);//使能清“0”
 283   1        LCD1602_Write(0x0C,0);delay(10);//设置开显示，不显示光标
 284   1        LCD1602_Write(0x06,0);delay(10);//写入新数据后显示屏整体不移动仅光标右移
 285   1        LCD1602_Write(0x01,0);delay(10);//写入清屏命令
 286   1      }
 287          /********************************************************************/
 288          //显示字符函数LCD1602_DIS()，无形参和返回值
 289          /********************************************************************/
 290          void LCD1602_DIS(void)
 291          {
 292   1        u8 i;                 //定义控制循环变量i
 293   1        LCD1602_Write(0x80,0);//选择第一行
 294   1        delay(5);             //延时等待1602稳定
 295   1        for(i=0;i<16;i++)
 296   1        {
 297   2            LCD1602_Write(table1[i],1);//写入table1[]内容
 298   2            delay(1);
 299   2        }
 300   1        LCD1602_Write(0xC0,0);//选择第二行
 301   1        delay(5);             //延时等待1602稳定
 302   1        for(i=0;i<16;i++)
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:43:12 PAGE 6   

 303   1        {
 304   2            LCD1602_Write(table2[i],1);//写入table2[]内容
 305   2            delay(1);
 306   2        }
 307   1      }
 308          /********************************************************************/
 309          //写入液晶模组命令或数据函数LCD1602_Write()，有形参cmdordata
 310          //和writetype，无返回值
 311          /********************************************************************/
 312          void LCD1602_Write(u8 cmdordata,u8 writetype)
 313          {
 314   1        u8 temp=0;                //定义数据处理中间变量
 315   1        LCDRS=writetype;          //判断写入类型0为命令1为数据
 316   1        delay(2);                 //延时等待稳定
 317   1        LCDDATA&=0xF0;            //清数据引脚
 318   1        temp=cmdordata>>4;        //高四位移到低四位
 319   1        LCDDATA|=temp&0x0F;       //写高四位
 320   1        LCDEN=1;delay(2);         //使能置“1”
 321   1        LCDEN=0;delay(2);         //使能清“0”
 322   1        LCDDATA&=0xF0;            //清数据引脚
 323   1        LCDDATA|=cmdordata&0x0F;  //写低四位
 324   1        LCDEN=1;delay(2);         //使能置“1”
 325   1        LCDEN=0;delay(2);         //使能清“0”
 326   1      }
 327          /********************************************************************/
 328          //设定地址写入字符函数LCD1602_DIS_CHAR()，有形参x、y、z无返回值
 329          //x表示1602液晶的行，y表示列地址，z表示欲写入的字符
 330          /********************************************************************/
 331          void LCD1602_DIS_CHAR(u8 x,u8 y,u8 z)
 332          {
 333   1        u8 address;
 334   1        if(x==1)            //若欲显示在第一行
 335   1          address=0x80+y;   //第一行的行首地址+列地址
 336   1        else
 337   1          address=0xC0+y;   //第二行的行首地址+列地址
 338   1        LCD1602_Write(address,0);   //设定显示地址
 339   1        LCD1602_Write(z,1); //写入字符数据
 340   1      }
 341          /********************************************************************/
 342          //OTP语音合成函数TTS_Prosser(),无形参，无返回值
 343          /********************************************************************/
 344          void TTS(u8 num)
 345          {
 346   1        ROTP=1;         //拉高复位引脚
 347   1        Delay150us();   //保持150us
 348   1        ROTP=0;         //拉低复位引脚
 349   1        Delay150us();   //保持150us
 350   1        ROTP=1;         //拉高复位引脚
 351   1        Delay150us();   //保持150us
 352   1        ROTP=0;         //拉低复位引脚
 353   1        Delay150us();   //保持150us
 354   1        while(num>0)    //若选定播放段地址不为0，则正常播报
 355   1        {
 356   2          DATA=1;       //拉高数据引脚
 357   2          Delay150us(); //保持150us
 358   2          DATA=0;       //拉高数据引脚
 359   2          Delay150us(); //保持150us
 360   2          num--;        //发出num个脉冲指定要播报的段
 361   2        }
 362   1      }
 363          /********************************************************************/
 364          //读卡函数Read_Card()，无形参，有返回值temp
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:43:12 PAGE 7   

 365          /********************************************************************/
 366          u32 Read_Card(void)
 367          {
 368   1        u8 i=0;                   //起始位循环控制变量
 369   1        u8 timeout;               //超时计数变量
 370   1        u8 timeout_flag;          //超时标志
 371   1        u8 row,col;               //行列变量
 372   1        u8 row_parity;            //行校验变量
 373   1        u8 col_parity[5];         //列校验变量
 374   1        u8 M_data;                //数据位变量
 375   1        u32 temp;                 //卡号变量
 376   1        u32 search=0;             //搜索次数变量
 377   1        while(1)                  //进行完整的读卡过程
 378   1        {   
 379   2          //***************************************************
 380   2          if(search==10)          //若10次搜索都未发现有效数据帧
 381   2            return 0;             //则返回0
 382   2          else                    //否则
 383   2          search++;               //搜索次数值自增
 384   2          timeout=0;              //超时值清零
 385   2          //***************************************************
 386   2          while(Mcode==0)         //等待接收引脚出现低电平
 387   2          {
 388   3            if(timeout==TIME_OUT) //若超时值等于设定阈值
 389   3              break;              //直接跳出本次搜索
 390   3            else                  //若超时值小于设定阈值
 391   3              timeout++;          //超时值自增
 392   3          }
 393   2          //***************************************************
 394   2          if(timeout==100)        //若超时值等于100
 395   2            continue;             //结束本次搜索
 396   2          else                    //否则
 397   2            timeout=0;            //超时值清零
 398   2          //***************************************************
 399   2          delay384us();           //延时384us
 400   2          if(Mcode)               //开始寻找帧头起始位
 401   2          {  
 402   3            for(i=0;i<8;i++)      //循环8次判断和处理过程
 403   3            {   
 404   4              timeout=0;          //先把超时值清零
 405   4              while(Mcode)        //等待接收引脚为高电平
 406   4              { 
 407   5                if(timeout==TIME_OUT)   //若超时值等于设定阈值
 408   5                {   
 409   6                  timeout_flag=1;break; //判定为超时事件，直接退出
 410   6                }
 411   5                else timeout++;   //否则超时值自增
 412   5              }  
 413   4              delay384us();       //再延时384us，判断下一个位
 414   4              if(Mcode&&timeout_flag==0);
 415   4              //判断下一位是否为1且超时标指是否为0
 416   4              else                //两个条件中若有其一不满足
 417   4                break;            //则直接退出         
 418   4            }
 419   3            //***************************************************
 420   3            if(timeout_flag)      //若超时标志为1
 421   3            {   
 422   4              timeout_flag=0;continue;//则清零标志并退出本次循环
 423   4            }
 424   3            else;
 425   3            //***************************************************
 426   3            if(i==8)//若i=8，则说明帧头已被识别，现在开始接受数据
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:43:12 PAGE 8   

 427   3            { 
 428   4              timeout_flag=0;     //清零超时标志
 429   4              timeout=0;          //清零超时值
 430   4              while(Mcode)        //等待接收引脚为高电平
 431   4              {  
 432   5                if(timeout==TIME_OUT)   //若超时值等于设定阈值
 433   5                { 
 434   6                  timeout_flag=0;break; //判定为超时事件，直接退出
 435   6                }
 436   5                else timeout++;   //否则超时值自增
 437   5              }   
 438   4              if(timeout_flag)    //若超时标志为1 
 439   4              {
 440   5                timeout_flag=0;continue;//则清零标志并退出本次循环
 441   5              }
 442   4              else; 
 443   4              //***************************************************
 444   4              //将5个列校验值清零
 445   4              col_parity[0]=col_parity[1]=col_parity[2]=0;
 446   4              col_parity[3]=col_parity[4]=0;
 447   4              for(row=0;row<11;row++)
 448   4              //循环11次，接收11行数据（4个数据位+1个行校验值）
 449   4              {
 450   5                for(col=0,row_parity=0;col<5;col++)//接收数据每5个为一行
 451   5                {
 452   6                  delay384us();       //延时384us，判断下一个数据位
 453   6                  if(Mcode)
 454   6                    M_data=1;         //若接收引脚高电平，则数据位为1
 455   6                  else
 456   6                    M_data=0;         //否则，数据位为0
 457   6                  //***************************************************
 458   6                  if(col<4&&row<10)   //若接收数据位在0-3列且在1-10行内
 459   6                  //意思就是在有效数据区域内
 460   6                  {
 461   7                    temp<<=1;         //卡号变量左移1位
 462   7                    temp+=(u32)M_data;//把新的数据位加到卡号变量中
 463   7                  }
 464   6                  else;
 465   6                  //***************************************************
 466   6                  row_parity+=M_data; //将数据加到行校验变量
 467   6                  col_parity[col]+=M_data;//将数据加到列校验变量
 468   6                  //虽然第5列数据仅作校验，但也加上
 469   6                  timeout=0;          //清零超时值
 470   6                  while(Mcode==(bit)M_data) //等待接收引脚状态为停止位
 471   6                  {
 472   7                    if(timeout==TIME_OUT)   //若超时值等于设定阈值
 473   7                    { 
 474   8                      timeout_flag=1;break; //判定为超时事件，直接退出
 475   8                    }
 476   7                    else timeout++;   //否则超时值自增
 477   7                  }
 478   6                  if(timeout_flag)    //若超时标志为1 
 479   6                    break;            //则退出本次循环
 480   6                  else;
 481   6                }
 482   5                //***************************************************
 483   5                if(row<10)            //因为最后一行没有校验
 484   5                                      //所以要加限制
 485   5                {
 486   6                  if((row_parity&0x01)||timeout_flag)
 487   6                  //若校验出错或超时标识为1
 488   6                  {
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:43:12 PAGE 9   

 489   7                    temp=0;           //清零本次采集的卡号数据
 490   7                    timeout_flag=1;   //置位超时标志位
 491   7                    break;            //退出
 492   7                  }
 493   6                  else;
 494   6                }
 495   5                else;
 496   5              }
 497   4              //***************************************************
 498   4              //对最后接收的列校验进行判断并结束本次主循环
 499   4              if(timeout_flag||((col_parity[0]&0x01)&&\
 500   4                (col_parity[1]&0x01)&&(col_parity[2]&0x01)&&\
 501   4              (col_parity[3]&0x01)))
 502   4              {                 //最后一列是没有校验的                         
 503   5                timeout_flag=0; //清零超时标志位
 504   5                temp=0;         //清零本次采集的卡号数据
 505   5                continue;       //退出本次循环
 506   5              } 
 507   4              else
 508   4                return temp;    //将卡号数据返回
 509   4            }
 510   3            continue;           //退出本次循环
 511   3          }
 512   2          continue;             //退出本次循环
 513   2        }
 514   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1908    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     44      24
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
