C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:44:08 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /******************************************************************
   2           * 实验名称：液晶+语音+HID免驱读卡器实验
   3           * 可配书籍：上册-《深入浅出STC8增强型51单片机进阶攻略》已经出版
   4                       下册-《深入浅出STC8增强型51单片机实战攻略》还在写作
   5           * 书籍备注：龙顺宇编著 清华大学出版社出版
   6           * 淘宝店铺：https://520mcu.taobao.com/
   7           * 实验平台：思修电子工作室SX-RFID-B低频ID识别与应用开发板 Long
   8           * 芯片型号：STC8G1K08/17（微调后可移植至STC8A/F/C/G/H系列单片机）
   9           * 时钟说明：芯片内部12MHz，在使用STC-ISP软件时需要先配置然后下载
  10           *           到单片机使得时钟配置生效。
  11           * 串口速率：9600bps
  12           * 实验说明：断电前提下向开发板插入1602液晶模块，然后用USB线插入到
  13           Uart-USB接口给开发板供电，做好STC-ISP配置并下载程序，程序下载完成
  14           后拔掉Uart-USB线，再把USB线插到开发板的HID-USB接口，打开word文档、
  15           文本文档或在keil源码编辑界面，将光标置于可编辑区，同时观察1602液
  16           晶上的显示情况（第一行显示“10b:”，第二行显示“08b:”），我们在开发
  17           板上方5-15cm处放置卡片，可以看到3个效果，效果1是电脑光标处免驱打
  18           印了卡号信息，效果2是液晶上显示了10位和8位卡号，效果3是听到语音播
  19           报卡号，本实验是综合性实验，以此学习免驱动、Manchester解码、语音
  20           播报、液晶显示等内容实现。
  21          ******************************************************************/
  22          #include  "STC8G.h"       //主控芯片的头文件
  23          #include  "stdio.h"       //程序要用到printf()故而添加此头文件
  24          #include  "intrins.h"     //因为要用到nop()函数故而包含此文件
  25          /************************常用数据类型定义*************************/
  26          #define u8  uint8_t
  27          #define u16 uint16_t
  28          #define u32 uint32_t
  29          typedef unsigned char    uint8_t;
  30          typedef unsigned int     uint16_t;
  31          typedef unsigned long    uint32_t;
  32          /************************端口/引脚定义区域************************/
  33          sbit Mcode=P3^2;          //曼彻斯特码输入端
  34          sbit ROTP=P1^7;           //OTP语音芯片复位脚
  35          sbit DATA=P1^5;           //OTP语音芯片数据脚
  36          sbit BUSY=P1^4;           //OTP语音芯片判忙脚
  37          sbit LCDRS=P3^6;          //LCD1602数据/命令选择端口
  38          sbit LCDEN=P3^7;          //LCD1602使能信号端口
  39          #define LCDDATA  P1       //LCD1602数据端口（仅用DB4至DB7）
  40          /************************用户自定义数据区域***********************/
  41          #define SYSCLK 12000000UL //系统时钟频率值
  42          #define BAUD_SET  (65536-SYSCLK/9600/4)//波特率设定与计算 
  43          #define TIME_OUT  256     //最大超时阈值
  44          u8 table1[]="10b:            ";//LCD1602显示10位卡号
  45          u8 table2[]="08b:            ";//LCD1602显示8位卡号
  46          /*1:不放内容，2:滴（音效），3:错误提示音（音效），4:欢迎使用思修
  47          电子射频识别开发板，5:模拟门禁模式，6:模拟公交模式，7:刷卡成功，
  48          8:十位卡号为，9:八位卡号为，10:0，11:1，12:2，13:3，14:4，15:5，
  49          16:6，17:7，18:8，19:9，20:管理卡，21:用户卡，22:学生卡，23:老年
  50          卡，24:卡片有效，解锁成功，25:卡片非法，解锁失败，26:按键，27:识
  51          别成功，28:扣费成功，29:免费乘车*/
  52          /**************************函数声明区域***************************/
  53          void delay(u16 Count);    //延时函数
  54          void Delay150us(void);    //150us延时函数
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:44:08 PAGE 2   

  55          void delay384us(void);    //384us延时函数
  56          void IO_init(void);       //IO初始化函数
  57          void SYSCLK_CCO(u8 TYPE,u8 SET_F,u8 SET_P);//系统时钟输出函数
  58          void LCD1602_Write(u8 cmdordata,u8 writetype);
  59          //写入液晶模组命令或数据函数
  60          void LCD1602_init(void);  //LCD1602初始化函数
  61          void LCD1602_DIS(void);   //显示字符函数
  62          void LCD1602_DIS_CHAR(u8 x,u8 y,u8 z);//在设定地址写入字符数据函数
  63          void UART1_Init(void);    //串口1初始化函数
  64          void U1SEND_C(u8 SEND_C); //串口1发送单字符数据函数
  65          char putchar(char ch);    //发送字符重定向函数
  66          void TTS(u8 num);         //OTP语音合成函数
  67          u32 Read_Card(void);      //读卡函数
  68          /***************************主函数区域****************************/
  69          void main(void)
  70          {
  71   1        u32 SN=0;               //定义卡号接收变量
  72   1        u16 a;                  //定义8位卡号的首部
  73   1        u32 b;                  //定义8位卡号的尾部
  74   1        static u8 bit10_0,bit10_1,bit10_2,bit10_3,bit10_4,bit10_5,\
  75   1        bit10_6,bit10_7,bit10_8,bit10_9;//定义10位卡号的每一位
  76   1        static u8 bit8_0,bit8_1,bit8_2,bit8_3,bit8_4,bit8_5,bit8_6,bit8_7;
  77   1                                //定义8位卡号的每一位
  78   1        IO_init();              //IO初始化
  79   1        SYSCLK_CCO(1,96,1);     //P1.6输出96分频的内部高速时钟12M/96=125kHz
  80   1        UART1_Init();           //初始化串口1 
  81   1        LCDEN=1;delay(200);     //使能置“1”（防止复位乱码）
  82   1        LCDEN=0;delay(200);     //使能清“0”（防止复位乱码）
  83   1        LCD1602_init();         //LCD1602初始化
  84   1        delay(200);             //延时等待稳定
  85   1        LCD1602_DIS();          //显示字符效果
  86   1        while(1)
  87   1        {
  88   2          SN=Read_Card();       //读取卡号数据
  89   2          if(SN)                //若卡号不为0，即有效卡号
  90   2          {
  91   3            //完成10位卡号的取位
  92   3            bit10_0=SN/1000000000;              //取出10位卡号第1位
  93   3            bit10_1=SN%1000000000/100000000;    //取出10位卡号第2位
  94   3            bit10_2=SN%100000000/10000000;      //取出10位卡号第3位
  95   3            bit10_3=SN%10000000/1000000;        //取出10位卡号第4位
  96   3            bit10_4=SN%1000000/100000;          //取出10位卡号第5位
  97   3            bit10_5=SN%100000/10000;            //取出10位卡号第6位
  98   3            bit10_6=SN%10000/1000;              //取出10位卡号第7位
  99   3            bit10_7=SN%1000/100;                //取出10位卡号第8位
 100   3            bit10_8=SN%100/10;                  //取出10位卡号第9位
 101   3            bit10_9=SN%10;                      //取出10位卡号第10位
 102   3            //算出8位卡号的首部和尾部
 103   3            a=(SN/16/16/16/16/16%16)*16+(SN/16/16/16/16%16);
 104   3            b=(SN/16/16/16%16)*4096+(SN/16/16%16)*256+(SN/16%16)*16+(SN%16);
 105   3            bit8_0=a/100;                       //取出8位卡号第1位
 106   3            bit8_1=a%100/10;                    //取出8位卡号第2位
 107   3            bit8_2=a%10;                        //取出8位卡号第3位
 108   3            bit8_3=b/10000;                     //取出8位卡号第4位
 109   3            bit8_4=b%10000/1000;                //取出8位卡号第5位
 110   3            bit8_5=b%1000/100;                  //取出8位卡号第6位
 111   3            bit8_6=b%100/10;                    //取出8位卡号第7位
 112   3            bit8_7=b%10;                        //取出8位卡号第8位
 113   3            //打印10位卡号
 114   3            printf("10b-ID:%c%c%c%c%c%c%c%c%c%c,",bit10_0+0x30,\
 115   3            bit10_1+0x30,bit10_2+0x30,bit10_3+0x30,bit10_4+0x30,\
 116   3            bit10_5+0x30,bit10_6+0x30,bit10_7+0x30,bit10_8+0x30,\
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:44:08 PAGE 3   

 117   3            bit10_9+0x30);
 118   3            //打印8位卡号
 119   3            printf("8b-ID:%c%c%c%c%c%c%c%c\r\n",bit8_0+0x30,bit8_1+0x30,\
 120   3            bit8_2+0x30,bit8_3+0x30,bit8_4+0x30,bit8_5+0x30,bit8_6+0x30,\
 121   3            bit8_7+0x30);
 122   3            //显示10位卡号
 123   3            LCD1602_DIS_CHAR(1,5, bit10_0+0x30);  //显示10位卡号第1位
 124   3            LCD1602_DIS_CHAR(1,6, bit10_1+0x30);  //显示10位卡号第2位
 125   3            LCD1602_DIS_CHAR(1,7, bit10_2+0x30);  //显示10位卡号第3位
 126   3            LCD1602_DIS_CHAR(1,8, bit10_3+0x30);  //显示10位卡号第4位
 127   3            LCD1602_DIS_CHAR(1,9, bit10_4+0x30);  //显示10位卡号第5位
 128   3            LCD1602_DIS_CHAR(1,10,bit10_5+0x30);  //显示10位卡号第6位
 129   3            LCD1602_DIS_CHAR(1,11,bit10_6+0x30);  //显示10位卡号第7位
 130   3            LCD1602_DIS_CHAR(1,12,bit10_7+0x30);  //显示10位卡号第8位
 131   3            LCD1602_DIS_CHAR(1,13,bit10_8+0x30);  //显示10位卡号第9位
 132   3            LCD1602_DIS_CHAR(1,14,bit10_9+0x30);  //显示10位卡号第10位
 133   3            //显示8位卡号
 134   3            /*转换方法：10位卡号转换为十六进制数是4个字节, 第一个字节舍弃,
 135   3            第二个字节转换为8位卡号的前3位，第三个和第四个字节一起转换为8
 136   3            位卡号的后5位即可。例如：某卡片的十位卡号0319631142对应的十六
 137   3            进制形式为130D2F26，先把第一个字节“13”舍弃，把第二个字节“0D”转
 138   3            换为十进制就是13，第三个和第四个字节“2F26”转换为十进制就是12070，
 139   3            所以该卡片的8位形式就是13，12070。*/
 140   3            LCD1602_DIS_CHAR(2,5, bit8_0+0x30);   //显示8位卡号第1位
 141   3            LCD1602_DIS_CHAR(2,6, bit8_1+0x30);   //显示8位卡号第2位
 142   3            LCD1602_DIS_CHAR(2,7, bit8_2+0x30);   //显示8位卡号第3位
 143   3            LCD1602_DIS_CHAR(2,8,',');            //显示8位卡号首部分隔符
 144   3            LCD1602_DIS_CHAR(2,9, bit8_3+0x30);   //显示8位卡号第4位
 145   3            LCD1602_DIS_CHAR(2,10,bit8_4+0x30);   //显示8位卡号第5位
 146   3            LCD1602_DIS_CHAR(2,11,bit8_5+0x30);   //显示8位卡号第6位
 147   3            LCD1602_DIS_CHAR(2,12,bit8_6+0x30);   //显示8位卡号第7位
 148   3            LCD1602_DIS_CHAR(2,13,bit8_7+0x30);   //显示8位卡号第8位
 149   3            //合成语音“滴，刷卡成功，十位卡号为：具体卡号”
 150   3            TTS(1);while(!BUSY);          //播报1段并等待完成（无内容）
 151   3            TTS(2);while(!BUSY);          //播报2段并等待完成（滴）
 152   3            TTS(7);while(!BUSY);          //播报7段并等待完成（刷卡成功）
 153   3            TTS(8);while(!BUSY);          //播报8段并等待完成（十位卡号为）
 154   3            //播报10位卡号
 155   3            TTS(bit10_0+10);while(!BUSY); //播报10位卡号第1位
 156   3            TTS(bit10_1+10);while(!BUSY); //播报10位卡号第2位
 157   3            TTS(bit10_2+10);while(!BUSY); //播报10位卡号第3位
 158   3            TTS(bit10_3+10);while(!BUSY); //播报10位卡号第4位
 159   3            TTS(bit10_4+10);while(!BUSY); //播报10位卡号第5位
 160   3            TTS(bit10_5+10);while(!BUSY); //播报10位卡号第6位
 161   3            TTS(bit10_6+10);while(!BUSY); //播报10位卡号第7位
 162   3            TTS(bit10_7+10);while(!BUSY); //播报10位卡号第8位
 163   3            TTS(bit10_8+10);while(!BUSY); //播报10位卡号第9位
 164   3            TTS(bit10_9+10);while(!BUSY); //播报10位卡号第10位
 165   3            SN=0;//清零卡号
 166   3          }
 167   2        }
 168   1      }
 169          /****************************************************************/
 170          //延时函数delay()，有形参Count用于控制延时函数执行次数，无返回值
 171          /****************************************************************/
 172          void delay(u16 Count)
 173          {
 174   1        u8 i,j;
 175   1        while (Count--)
 176   1        {
 177   2          for(i=0;i<50;i++)
 178   2            for(j=0;j<20;j++);
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:44:08 PAGE 4   

 179   2        }
 180   1      }
 181          /********************************************************************/
 182          //150us延时函数Delay150us()，无形参，无返回值，这是用STC-ISP算出
 183          //来的150us延时，此延时可以不严格，但应大于50us小于200us
 184          /********************************************************************/
 185          void Delay150us(void)//@12MHz
 186          {
 187   1        u8 i, j;
 188   1        _nop_();
 189   1        _nop_();
 190   1        i=3;
 191   1        j=83;
 192   1        do
 193   1        {
 194   2          while(--j);
 195   2        } while(--i);
 196   1      }
 197          /****************************************************************/
 198          //384us延时函数delay384us()，无形参，无返回值，这是用STC-ISP算出
 199          //来的384us延时，此延时可以不严格，但应大于256us小于512us
 200          /****************************************************************/
 201          void delay384us(void)//@12MHz
 202          {
 203   1        u8 i, j;
 204   1        _nop_();
 205   1        _nop_();
 206   1        i=6;
 207   1        j=249;
 208   1        do
 209   1        {
 210   2          while(--j);
 211   2        } while(--i);
 212   1      }
 213          /****************************************************************/
 214          //IO初始化函数IO_Init()，无形参，无返回值
 215          /****************************************************************/
 216          void IO_init(void)
 217          {
 218   1        //配置P1.6为推挽/强上拉模式
 219   1        P1M0|=0x40;     //P1M0.6=1
 220   1        P1M1&=0xBF;     //P1M1.6=0
 221   1        //配置P3.2为准双向/弱上拉模式
 222   1        P3M0&=0xFB;     //P3M0.2=0
 223   1        P3M1&=0xFB;     //P3M1.2=0
 224   1        //配置P3.6-7为准双向/弱上拉模式
 225   1        P3M0&=0x3F;     //P3M0.6-7=0
 226   1        P3M1&=0x3F;     //P3M1.6-7=0
 227   1        //配置P1.0-3为准双向/弱上拉模式
 228   1        P1M0&=0xF0;     //P1M0.0-3=0
 229   1        P1M1&=0xF0;     //P1M1.0-3=0
 230   1        //配置P1.4为准双向/弱上拉模式
 231   1        P1M0&=0xEF;     //P1M0.4=0
 232   1        P1M1&=0xEF;     //P1M1.4=0
 233   1        //配置P1.5为推挽输出模式
 234   1        P1M0|=0x20;     //P1M0.5=1
 235   1        P1M1&=0xDF;     //P1M1.5=0
 236   1        //配置P1.7为推挽输出模式
 237   1        P1M0|=0x80;     //P1M0.7=1
 238   1        P1M1&=0x7F;     //P1M1.7=0
 239   1        delay(10);      //等待I/O模式配置稳定
 240   1        ROTP=1;         //拉高复位引脚
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:44:08 PAGE 5   

 241   1        DATA=1;         //拉高数据引脚
 242   1      }
 243          /********************************************************************/
 244          //系统时钟输出函数SYSCLK_CCO()，有形参TYPE用于选择时钟源（0-外部时钟）
 245          //（1-片内高速时钟）（2-片内低速时钟），有形参SET_F用于指定时钟源
 246          //分频系数，有形参SET_P用于指定输出引脚的选择（P5.4/P1.6）无返回值
 247          /********************************************************************/
 248          void SYSCLK_CCO(u8 TYPE,u8 SET_F,u8 SET_P)
 249          {
 250   1        P_SW2|=0x80;          //允许访问扩展特殊功能寄存器XSFR
 251   1        switch(TYPE)
 252   1        {
 253   2          case 0:
 254   2          {
 255   3            XOSCCR|=0xC0;     //使能外部晶体振荡器
 256   3            while(!(XOSCCR&0x01));//等待外部时钟稳定
 257   3            //配置MCKSEL[1:0]=“01”，选择外部时钟
 258   3            CLKSEL&=0xFD;     //清零MCKSEL[1:0]的高位
 259   3            CLKSEL|=0x01;     //配置MCKSEL[1:0]的低位
 260   3          }break;   
 261   2          case 1:             //若选择片内高速时钟，则无需配置时钟选择
 262   2          {}break;
 263   2          case 2:
 264   2          {
 265   3            IRC32KCR|=0x80;   //使能内部32kHz低速IRC控制寄存器
 266   3            while(!(IRC32KCR&0x01));//等待内部低速时钟稳定
 267   3            CLKSEL|=0x03;     //配置MCKSEL[1:0]=“11”选择内部低速IRC时钟
 268   3          }break;
 269   2        }
 270   1        switch(SET_F)
 271   1        {
 272   2          case 1:{MCLKOCR&=0x80;MCLKOCR|=0x01;}break;   //Fsysclk/1
 273   2          case 2:{MCLKOCR&=0x80;MCLKOCR|=0x02;}break;   //Fsysclk/2
 274   2          case 4:{MCLKOCR&=0x80;MCLKOCR|=0x04;}break;   //Fsysclk/4
 275   2          case 8:{MCLKOCR&=0x80;MCLKOCR|=0x08;}break;   //Fsysclk/8
 276   2          case 16:{MCLKOCR&=0x80;MCLKOCR|=0x10;}break;  //Fsysclk/16
 277   2          case 32:{MCLKOCR&=0x80;MCLKOCR|=0x20;}break;  //Fsysclk/32
 278   2          case 64:{MCLKOCR&=0x80;MCLKOCR|=0x40;}break;  //Fsysclk/64
 279   2          case 96:{MCLKOCR&=0x80;MCLKOCR|=0x60;}break;  //Fsysclk/96
 280   2          case 127:{MCLKOCR&=0x80;MCLKOCR|=0x7F;}break; //Fsysclk/127
 281   2        }
 282   1        if(SET_P==0)
 283   1          MCLKOCR&=0x7F;      //配置时钟由P5.4引脚输出
 284   1        else
 285   1          MCLKOCR|=0x80;      //配置时钟由P1.6引脚输出
 286   1        P_SW2&=0x7F;          //结束并关闭XSFR访问
 287   1      }
 288          /********************************************************************/
 289          //LCD1602初始化函数LCD1602_init()，无形参和返回值
 290          /********************************************************************/
 291          void LCD1602_init(void)
 292          {
 293   1        LCD1602_Write(0x28,0);delay(10);//数据总线为4位，显示2行，5*7点阵/每字符
 294   1        LCDEN=1;delay(10);//使能置“1”
 295   1        LCDEN=0;delay(10);//使能清“0”
 296   1        LCD1602_Write(0x0C,0);delay(10);//设置开显示，不显示光标
 297   1        LCD1602_Write(0x06,0);delay(10);//写入新数据后显示屏整体不移动仅光标右移
 298   1        LCD1602_Write(0x01,0);delay(10);//写入清屏命令
 299   1      }
 300          /********************************************************************/
 301          //显示字符函数LCD1602_DIS()，无形参和返回值
 302          /********************************************************************/
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:44:08 PAGE 6   

 303          void LCD1602_DIS(void)
 304          {
 305   1        u8 i;                 //定义控制循环变量i
 306   1        LCD1602_Write(0x80,0);//选择第一行
 307   1        delay(5);             //延时等待1602稳定
 308   1        for(i=0;i<16;i++)
 309   1        {
 310   2            LCD1602_Write(table1[i],1);//写入table1[]内容
 311   2            delay(1);
 312   2        }
 313   1        LCD1602_Write(0xC0,0);//选择第二行
 314   1        delay(5);             //延时等待1602稳定
 315   1        for(i=0;i<16;i++)
 316   1        {
 317   2            LCD1602_Write(table2[i],1);//写入table2[]内容
 318   2            delay(1);
 319   2        }
 320   1      }
 321          /********************************************************************/
 322          //写入液晶模组命令或数据函数LCD1602_Write()，有形参cmdordata
 323          //和writetype，无返回值
 324          /********************************************************************/
 325          void LCD1602_Write(u8 cmdordata,u8 writetype)
 326          {
 327   1        u8 temp=0;                //定义数据处理中间变量
 328   1        LCDRS=writetype;          //判断写入类型0为命令1为数据
 329   1        delay(2);                 //延时等待稳定
 330   1        LCDDATA&=0xF0;            //清数据引脚
 331   1        temp=cmdordata>>4;        //高四位移到低四位
 332   1        LCDDATA|=temp&0x0F;       //写高四位
 333   1        LCDEN=1;delay(2);         //使能置“1”
 334   1        LCDEN=0;delay(2);         //使能清“0”
 335   1        LCDDATA&=0xF0;            //清数据引脚
 336   1        LCDDATA|=cmdordata&0x0F;  //写低四位
 337   1        LCDEN=1;delay(2);         //使能置“1”
 338   1        LCDEN=0;delay(2);         //使能清“0”
 339   1      }
 340          /********************************************************************/
 341          //设定地址写入字符函数LCD1602_DIS_CHAR()，有形参x、y、z无返回值
 342          //x表示1602液晶的行，y表示列地址，z表示欲写入的字符
 343          /********************************************************************/
 344          void LCD1602_DIS_CHAR(u8 x,u8 y,u8 z)
 345          {
 346   1        u8 address;
 347   1        if(x==1)            //若欲显示在第一行
 348   1          address=0x80+y;   //第一行的行首地址+列地址
 349   1        else
 350   1          address=0xC0+y;   //第二行的行首地址+列地址
 351   1        LCD1602_Write(address,0);   //设定显示地址
 352   1        LCD1602_Write(z,1); //写入字符数据
 353   1      }
 354          /********************************************************************/
 355          //串口1初始化函数UART1_Init()，无形参，无返回值
 356          /********************************************************************/
 357          void UART1_Init(void)
 358          {
 359   1        SCON=0x50;      //181结构，可变波特率，允许数据接收
 360   1        AUXR|=0x01;     //串口1选择定时器2为波特率发生器
 361   1        AUXR|=0x04;     //定时器时钟1T模式
 362   1        T2L=BAUD_SET;   //设置定时初始值
 363   1        T2H=BAUD_SET>>8;//设置定时初始值
 364   1        AUXR|=0x10;     //定时器2开始计时
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:44:08 PAGE 7   

 365   1        RI=0;TI=0;      //清除接收数据标志位和发送数据标志位
 366   1      }
 367          /********************************************************************/
 368          //串口1发送单字符数据函数U1SEND_C()，有形参SEND_C即为欲发送单字节
 369          //数据，无返回值
 370          /********************************************************************/
 371          void U1SEND_C(u8 SEND_C)
 372          {
 373   1        TI=0;           //清除发送完成标志位
 374   1        SBUF=SEND_C;    //发送数据
 375   1        while(!TI);     //等待数据发送完成
 376   1      }
 377          /********************************************************************/
 378          //发送字符重定向函数char putchar(char ch)，有形参ch，有返回值ch
 379          /********************************************************************/
 380          char putchar(char ch)
 381          {
 382   1        U1SEND_C((u8)ch);//通过串口1发送数据
 383   1        return ch;
 384   1      }
 385          /********************************************************************/
 386          //OTP语音合成函数TTS_Prosser(),无形参，无返回值
 387          /********************************************************************/
 388          void TTS(u8 num)
 389          {
 390   1        ROTP=1;         //拉高复位引脚
 391   1        Delay150us();   //保持150us
 392   1        ROTP=0;         //拉低复位引脚
 393   1        Delay150us();   //保持150us
 394   1        ROTP=1;         //拉高复位引脚
 395   1        Delay150us();   //保持150us
 396   1        ROTP=0;         //拉低复位引脚
 397   1        Delay150us();   //保持150us
 398   1        while(num>0)    //若选定播放段地址不为0，则正常播报
 399   1        {
 400   2          DATA=1;       //拉高数据引脚
 401   2          Delay150us(); //保持150us
 402   2          DATA=0;       //拉高数据引脚
 403   2          Delay150us(); //保持150us
 404   2          num--;        //发出num个脉冲指定要播报的段
 405   2        }
 406   1      }
 407          /********************************************************************/
 408          //读卡函数Read_Card()，无形参，有返回值temp
 409          /********************************************************************/
 410          u32 Read_Card(void)
 411          {
 412   1        u8 i=0;                   //起始位循环控制变量
 413   1        u8 timeout;               //超时计数变量
 414   1        u8 timeout_flag;          //超时标志
 415   1        u8 row,col;               //行列变量
 416   1        u8 row_parity;            //行校验变量
 417   1        u8 col_parity[5];         //列校验变量
 418   1        u8 M_data;                //数据位变量
 419   1        u32 temp;                 //卡号变量
 420   1        u32 search=0;             //搜索次数变量
 421   1        while(1)                  //进行完整的读卡过程
 422   1        {   
 423   2          //***************************************************
 424   2          if(search==10)          //若10次搜索都未发现有效数据帧
 425   2            return 0;             //则返回0
 426   2          else                    //否则
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:44:08 PAGE 8   

 427   2          search++;               //搜索次数值自增
 428   2          timeout=0;              //超时值清零
 429   2          //***************************************************
 430   2          while(Mcode==0)         //等待接收引脚出现低电平
 431   2          {
 432   3            if(timeout==TIME_OUT) //若超时值等于设定阈值
 433   3              break;              //直接跳出本次搜索
 434   3            else                  //若超时值小于设定阈值
 435   3              timeout++;          //超时值自增
 436   3          }
 437   2          //***************************************************
 438   2          if(timeout==100)        //若超时值等于100
 439   2            continue;             //结束本次搜索
 440   2          else                    //否则
 441   2            timeout=0;            //超时值清零
 442   2          //***************************************************
 443   2          delay384us();           //延时384us
 444   2          if(Mcode)               //开始寻找帧头起始位
 445   2          {  
 446   3            for(i=0;i<8;i++)      //循环8次判断和处理过程
 447   3            {   
 448   4              timeout=0;          //先把超时值清零
 449   4              while(Mcode)        //等待接收引脚为高电平
 450   4              { 
 451   5                if(timeout==TIME_OUT)   //若超时值等于设定阈值
 452   5                {   
 453   6                  timeout_flag=1;break; //判定为超时事件，直接退出
 454   6                }
 455   5                else timeout++;   //否则超时值自增
 456   5              }  
 457   4              delay384us();       //再延时384us，判断下一个位
 458   4              if(Mcode&&timeout_flag==0);
 459   4              //判断下一位是否为1且超时标指是否为0
 460   4              else                //两个条件中若有其一不满足
 461   4                break;            //则直接退出         
 462   4            }
 463   3            //***************************************************
 464   3            if(timeout_flag)      //若超时标志为1
 465   3            {   
 466   4              timeout_flag=0;continue;//则清零标志并退出本次循环
 467   4            }
 468   3            else;
 469   3            //***************************************************
 470   3            if(i==8)//若i=8，则说明帧头已被识别，现在开始接受数据
 471   3            { 
 472   4              timeout_flag=0;     //清零超时标志
 473   4              timeout=0;          //清零超时值
 474   4              while(Mcode)        //等待接收引脚为高电平
 475   4              {  
 476   5                if(timeout==TIME_OUT)   //若超时值等于设定阈值
 477   5                { 
 478   6                  timeout_flag=0;break; //判定为超时事件，直接退出
 479   6                }
 480   5                else timeout++;   //否则超时值自增
 481   5              }   
 482   4              if(timeout_flag)    //若超时标志为1 
 483   4              {
 484   5                timeout_flag=0;continue;//则清零标志并退出本次循环
 485   5              }
 486   4              else; 
 487   4              //***************************************************
 488   4              //将5个列校验值清零
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:44:08 PAGE 9   

 489   4              col_parity[0]=col_parity[1]=col_parity[2]=0;
 490   4              col_parity[3]=col_parity[4]=0;
 491   4              for(row=0;row<11;row++)
 492   4              //循环11次，接收11行数据（4个数据位+1个行校验值）
 493   4              {
 494   5                for(col=0,row_parity=0;col<5;col++)//接收数据每5个为一行
 495   5                {
 496   6                  delay384us();       //延时384us，判断下一个数据位
 497   6                  if(Mcode)
 498   6                    M_data=1;         //若接收引脚高电平，则数据位为1
 499   6                  else
 500   6                    M_data=0;         //否则，数据位为0
 501   6                  //***************************************************
 502   6                  if(col<4&&row<10)   //若接收数据位在0-3列且在1-10行内
 503   6                  //意思就是在有效数据区域内
 504   6                  {
 505   7                    temp<<=1;         //卡号变量左移1位
 506   7                    temp+=(u32)M_data;//把新的数据位加到卡号变量中
 507   7                  }
 508   6                  else;
 509   6                  //***************************************************
 510   6                  row_parity+=M_data; //将数据加到行校验变量
 511   6                  col_parity[col]+=M_data;//将数据加到列校验变量
 512   6                  //虽然第5列数据仅作校验，但也加上
 513   6                  timeout=0;          //清零超时值
 514   6                  while(Mcode==(bit)M_data) //等待接收引脚状态为停止位
 515   6                  {
 516   7                    if(timeout==TIME_OUT)   //若超时值等于设定阈值
 517   7                    { 
 518   8                      timeout_flag=1;break; //判定为超时事件，直接退出
 519   8                    }
 520   7                    else timeout++;   //否则超时值自增
 521   7                  }
 522   6                  if(timeout_flag)    //若超时标志为1 
 523   6                    break;            //则退出本次循环
 524   6                  else;
 525   6                }
 526   5                //***************************************************
 527   5                if(row<10)            //因为最后一行没有校验
 528   5                                      //所以要加限制
 529   5                {
 530   6                  if((row_parity&0x01)||timeout_flag)
 531   6                  //若校验出错或超时标识为1
 532   6                  {
 533   7                    temp=0;           //清零本次采集的卡号数据
 534   7                    timeout_flag=1;   //置位超时标志位
 535   7                    break;            //退出
 536   7                  }
 537   6                  else;
 538   6                }
 539   5                else;
 540   5              }
 541   4              //***************************************************
 542   4              //对最后接收的列校验进行判断并结束本次主循环
 543   4              if(timeout_flag||((col_parity[0]&0x01)&&\
 544   4                (col_parity[1]&0x01)&&(col_parity[2]&0x01)&&\
 545   4              (col_parity[3]&0x01)))
 546   4              {                 //最后一列是没有校验的                         
 547   5                timeout_flag=0; //清零超时标志位
 548   5                temp=0;         //清零本次采集的卡号数据
 549   5                continue;       //退出本次循环
 550   5              } 
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:44:08 PAGE 10  

 551   4              else
 552   4                return temp;    //将卡号数据返回
 553   4            }
 554   3            continue;           //退出本次循环
 555   3          }
 556   2          continue;             //退出本次循环
 557   2        }
 558   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2571    ----
   CONSTANT SIZE    =     54    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     52      30
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
