/******************************************************************
 * 实验名称：串口打印Manchester解码实验
******************************************************************/
#include	"STC8G.h"				//主控芯片的头文件
#include  "stdio.h"				//程序要用到printf()故而添加此头文件
#include  "intrins.h"			//因为要用到nop()函数故而包含此文件
/************************常用数据类型定义*************************/
#define u8  uint8_t
#define u16 uint16_t
#define u32 uint32_t
typedef unsigned char    uint8_t;
typedef unsigned int     uint16_t;
typedef unsigned long    uint32_t;
/************************端口/引脚定义区域************************/
sbit Mcode=P3^2;  				//曼彻斯特码输入端
/************************用户自定义数据区域***********************/
#define SYSCLK 12000000UL	//系统时钟频率值
#define BAUD_SET  (65536-SYSCLK/9600/4)//波特率设定与计算 
#define TIME_OUT  256			//最大超时阈值
/**************************函数声明区域***************************/
void delay(u16 Count);		//延时函数
void delay384us(void);		//384us延时函数
void IO_init(void);   		//IO初始化函数
void SYSCLK_CCO(u8 TYPE,u8 SET_F,u8 SET_P);//系统时钟输出函数
void UART1_Init(void);		//串口1初始化函数
void U1SEND_C(u8 SEND_C);	//串口1发送单字符数据函数
char putchar(char ch);		//发送字符重定向函数
u32 Read_Card(void);			//读卡函数
/***************************主函数区域****************************/
void main(void)
{
 	u32 SN=0;								//定义卡号接收变量
	IO_init();							//IO初始化	
	SYSCLK_CCO(1,96,1);			//P1.6输出96分频的内部高速时钟12M/96=125kHz
	UART1_Init();						//初始化串口1
	while(1)
	{
		SN=Read_Card();				//读取卡号数据
		if(SN)								//若卡号不为0，即有效卡号
		{
			printf("ID: (%lX)H,",SN);	//以十六进制数形式打印卡号数据
			printf(" (%ld)D.\r\n",SN);//以长整型形式打印卡号数据
			SN=0;								//清零卡号
		}
	}
}
/****************************************************************/
//延时函数delay()，有形参Count用于控制延时函数执行次数，无返回值
/****************************************************************/
void delay(u16 Count)
{
  u8 i,j;
  while (Count--)
  {
    for(i=0;i<50;i++)
      for(j=0;j<20;j++);
  }
}
/****************************************************************/
//384us延时函数delay384us()，无形参，无返回值，这是用STC-ISP算出
//来的384us延时，此延时可以不严格，但应大于256us小于512us
/****************************************************************/
void delay384us(void)//@12MHz
{
	u8 i, j;
	_nop_();
	_nop_();
	i=6;
	j=249;
	do
	{
		while(--j);
	} while(--i);
}
/****************************************************************/
//IO初始化函数IO_Init()，无形参，无返回值
/****************************************************************/
void IO_init(void)
{
	//配置P1.6为推挽/强上拉模式
	P1M0|=0x40;			//P1M0.6=1
	P1M1&=0xBF;			//P1M1.6=0
	//配置P3.2为准双向/弱上拉模式
	P3M0&=0xFB;			//P3M0.2=0
	P3M1&=0xFB;			//P3M1.2=0
	delay(10);			//等待I/O模式配置稳定
}
/********************************************************************/
//系统时钟输出函数SYSCLK_CCO()，有形参TYPE用于选择时钟源（0-外部时钟）
//（1-片内高速时钟）（2-片内低速时钟），有形参SET_F用于指定时钟源
//分频系数，有形参SET_P用于指定输出引脚的选择（P5.4/P1.6）无返回值
/********************************************************************/
void SYSCLK_CCO(u8 TYPE,u8 SET_F,u8 SET_P)
{
	P_SW2|=0x80;					//允许访问扩展特殊功能寄存器XSFR
	switch(TYPE)
	{
		case 0:
		{
			XOSCCR|=0xC0;			//使能外部晶体振荡器
			while(!(XOSCCR&0x01));//等待外部时钟稳定
			//配置MCKSEL[1:0]=“01”，选择外部时钟
			CLKSEL&=0xFD;			//清零MCKSEL[1:0]的高位
			CLKSEL|=0x01;			//配置MCKSEL[1:0]的低位
		}break;		
		case 1:							//若选择片内高速时钟，则无需配置时钟选择
		{}break;
		case 2:
		{
			IRC32KCR|=0x80;		//使能内部32kHz低速IRC控制寄存器
			while(!(IRC32KCR&0x01));//等待内部低速时钟稳定
			CLKSEL|=0x03;			//配置MCKSEL[1:0]=“11”选择内部低速IRC时钟
		}break;
	}
	switch(SET_F)
	{
		case 1:{MCLKOCR&=0x80;MCLKOCR|=0x01;}break;		//Fsysclk/1
		case 2:{MCLKOCR&=0x80;MCLKOCR|=0x02;}break;		//Fsysclk/2
		case 4:{MCLKOCR&=0x80;MCLKOCR|=0x04;}break;		//Fsysclk/4
		case 8:{MCLKOCR&=0x80;MCLKOCR|=0x08;}break;		//Fsysclk/8
		case 16:{MCLKOCR&=0x80;MCLKOCR|=0x10;}break;	//Fsysclk/16
		case 32:{MCLKOCR&=0x80;MCLKOCR|=0x20;}break;	//Fsysclk/32
		case 64:{MCLKOCR&=0x80;MCLKOCR|=0x40;}break;	//Fsysclk/64
		case 96:{MCLKOCR&=0x80;MCLKOCR|=0x60;}break;	//Fsysclk/96
		case 127:{MCLKOCR&=0x80;MCLKOCR|=0x7F;}break;	//Fsysclk/127
	}
	if(SET_P==0)
		MCLKOCR&=0x7F;			//配置时钟由P5.4引脚输出
	else
		MCLKOCR|=0x80;			//配置时钟由P1.6引脚输出
	P_SW2&=0x7F; 					//结束并关闭XSFR访问
}
/********************************************************************/
//串口1初始化函数UART1_Init()，无形参，无返回值
/********************************************************************/
void UART1_Init(void)
{
	SCON=0x50;			//181结构，可变波特率，允许数据接收
	AUXR|=0x01;			//串口1选择定时器2为波特率发生器
	AUXR|=0x04;			//定时器时钟1T模式
	T2L=BAUD_SET;		//设置定时初始值
	T2H=BAUD_SET>>8;//设置定时初始值
	AUXR|=0x10;			//定时器2开始计时
	RI=0;TI=0;			//清除接收数据标志位和发送数据标志位
}
/********************************************************************/
//串口1发送单字符数据函数U1SEND_C()，有形参SEND_C即为欲发送单字节
//数据，无返回值
/********************************************************************/
void U1SEND_C(u8 SEND_C)
{
	TI=0;						//清除发送完成标志位
	SBUF=SEND_C;		//发送数据
	while(!TI);			//等待数据发送完成
}
/********************************************************************/
//发送字符重定向函数char putchar(char ch)，有形参ch，有返回值ch
/********************************************************************/
char putchar(char ch)
{
	U1SEND_C((u8)ch);//通过串口1发送数据
	return ch;
}
/********************************************************************/
//读卡函数Read_Card()，无形参，有返回值temp
/********************************************************************/
u32 Read_Card(void)
{
	return 0;
	
}