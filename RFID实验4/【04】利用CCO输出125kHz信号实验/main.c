/*********************************************************************
 * 实验名称：利用CCO输出125kHz信号实验
 * 可配书籍：上册-《深入浅出STC8增强型51单片机进阶攻略》已经出版
						 下册-《深入浅出STC8增强型51单片机实战攻略》还在写作
 * 书籍备注：龙顺宇编著 清华大学出版社出版
 * 淘宝店铺：https://520mcu.taobao.com/
 * 实验平台：思修电子工作室SX-RFID-B低频ID识别与应用开发板 Long
 * 芯片型号：STC8G1K08/17（微调后可移植至STC8A/F/C/G/H系列单片机）
 * 时钟说明：芯片内部12MHz，在使用STC-ISP软件时需要先配置然后下载到
             单片机使得时钟配置生效。
 * 实验说明：将逻辑分析仪或者示波器的通道1连接到主控单片机的P1.6引脚
 （即开发板激励信号选择的“M”引针），将逻辑分析仪或者示波器的地与开发
 板进行共地处理。将USB线插入开发板的Uart-USB接口，检查无误后给开发板
 上电，做好STC-ISP配置并下载程序，可观察到逻辑分析仪或者示波器上出现
 了125kHz左右的时钟信号输出，从而学习CCO功能让内部高速时钟进行96分频
 得到125kHz信号的方法和效果。
*********************************************************************/
#include	"STC8H.h"			//主控芯片的头文件
/***************************常用数据类型定义*************************/
#define u8  uint8_t
#define u16 uint16_t
#define u32 uint32_t
typedef unsigned char  uint8_t;
typedef unsigned int   uint16_t;
typedef unsigned long  uint32_t;
/***************************端口/引脚定义区域************************/
/***************************用户自定义数据区域***********************/
/*****************************函数声明区域***************************/
void delay(u16 Count);	//延时函数
void IO_init(void);     //IO初始化函数
void SYSCLK_CCO(u8 TYPE,u8 SET_F,u8 SET_P);//系统时钟输出函数
/******************************主函数区域****************************/
void main(void)
{
	IO_init();						//IO初始化
	SYSCLK_CCO(1,96,1);		//P1.6输出96分频的内部高速时钟12M/96=125kHz
	while(1);							//程序“停止”
}
/********************************************************************/
//延时函数delay()，有形参Count用于控制延时函数执行次数，无返回值
/********************************************************************/
void delay(u16 Count)
{
  u8 i,j;
  while(Count--)
  {
    for(i=0;i<50;i++)
      for(j=0;j<20;j++);
  }
}
/********************************************************************/
//IO初始化函数IO_Init()，无形参，无返回值
/********************************************************************/
void IO_init(void)
{
	//配置P1.6为推挽/强上拉模式
	P1M0|=0x40;						//P1M0.6=1
	P1M1&=0xBF;						//P1M1.6=0
	//配置P5.4为推挽/强上拉模式
	//P5M0|=0x10;					//P5M0.4=1
	//P5M1&=0xEF;					//P5M1.4=0
	delay(10);						//等待I/O模式配置稳定
}
/********************************************************************/
//系统时钟输出函数SYSCLK_CCO()，有形参TYPE用于选择时钟源（0-外部时钟）
//（1-片内高速时钟）（2-片内低速时钟），有形参SET_F用于指定时钟源
//分频系数，有形参SET_P用于指定输出引脚的选择（P5.4/P1.6）无返回值
/********************************************************************/
void SYSCLK_CCO(u8 TYPE,u8 SET_F,u8 SET_P)
{
	P_SW2|=0x80;					//允许访问扩展特殊功能寄存器XSFR
	switch(TYPE)
	{
		case 0:
		{
			XOSCCR|=0xC0;			//使能外部晶体振荡器
			while(!(XOSCCR&0x01));//等待外部时钟稳定
			//配置MCKSEL[1:0]=“01”，选择外部时钟
			CLKSEL&=0xFD;			//清零MCKSEL[1:0]的高位
			CLKSEL|=0x01;			//配置MCKSEL[1:0]的低位
		}break;		
		case 1:							//若选择片内高速时钟，则无需配置时钟选择
		{}break;
		case 2:
		{
			IRC32KCR|=0x80;		//使能内部32kHz低速IRC控制寄存器
			while(!(IRC32KCR&0x01));//等待内部低速时钟稳定
			CLKSEL|=0x03;			//配置MCKSEL[1:0]=“11”选择内部低速IRC时钟
		}break;
	}
	switch(SET_F)
	{
		case 1:{MCLKOCR&=0x80;MCLKOCR|=0x01;}break;		//Fsysclk/1
		case 2:{MCLKOCR&=0x80;MCLKOCR|=0x02;}break;		//Fsysclk/2
		case 4:{MCLKOCR&=0x80;MCLKOCR|=0x04;}break;		//Fsysclk/4
		case 8:{MCLKOCR&=0x80;MCLKOCR|=0x08;}break;		//Fsysclk/8
		case 16:{MCLKOCR&=0x80;MCLKOCR|=0x10;}break;	//Fsysclk/16
		case 32:{MCLKOCR&=0x80;MCLKOCR|=0x20;}break;	//Fsysclk/32
		case 64:{MCLKOCR&=0x80;MCLKOCR|=0x40;}break;	//Fsysclk/64
		case 96:{MCLKOCR&=0x80;MCLKOCR|=0x60;}break;	//Fsysclk/96
		case 127:{MCLKOCR&=0x80;MCLKOCR|=0x7F;}break;	//Fsysclk/127
	}
	if(SET_P==0)
		MCLKOCR&=0x7F;			//配置时钟由P5.4引脚输出
	else
		MCLKOCR|=0x80;			//配置时钟由P1.6引脚输出
	P_SW2&=0x7F; 					//结束并关闭XSFR访问
}