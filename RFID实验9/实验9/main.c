#include	"STC8G.h"				//主控芯片的头文件
#include  "intrins.h"			//因为要用到nop()函数故而包含此文件
/************************常用数据类型定义*************************/
#define u8  uint8_t
#define u16 uint16_t
#define u32 uint32_t
typedef unsigned char    uint8_t;
typedef unsigned int     uint16_t;
typedef unsigned long    uint32_t;
/************************端口/引脚定义区域************************/
sbit Mcode=P3^2;  				//曼彻斯特码输入端
sbit LCDRS=P3^6;    			//LCD1602数据/命令选择端口
sbit LCDEN=P3^7;     			//LCD1602使能信号端口
#define LCDDATA  P1  			//LCD1602数据端口（仅用DB4至DB7）
/************************用户自定义数据区域***********************/
u8 table1[]="ID:            H";//LCD1602显示十六进制卡号
u8 table2[]="ID:            D";//LCD1602显示十进制卡号
#define TIME_OUT  256			//最大超时阈值
u8 HEX[16]={'0','1','2','3','4','5','6','7','8','9','A','B','C',\
'D','E','F'};//十六进制转换字符数组
/**************************函数声明区域***************************/
void delay(u16 Count);		//延时函数
void delay384us(void);		//384us延时函数
void IO_init(void);   		//IO初始化函数
void SYSCLK_CCO(u8 TYPE,u8 SET_F,u8 SET_P);//系统时钟输出函数
void LCD1602_Write(u8 cmdordata,u8 writetype);
//写入液晶模组命令或数据函数
void LCD1602_init(void);	//LCD1602初始化函数
void LCD1602_DIS(void);		//显示字符函数
void LCD1602_DIS_CHAR(u8 x,u8 y,u8 z);//在设定地址写入字符数据函数
u32 Read_Card(void);			//读卡函数
/***************************主函数区域****************************/






/****************************************************************/
//384us延时函数delay384us()，无形参，无返回值，这是用STC-ISP算出
//来的384us延时，此延时可以不严格，但应大于256us小于512us
/****************************************************************/
void delay384us(void)//@12MHz
{
	u8 i, j;
	_nop_();
	_nop_();
	i=6;
	j=249;
	do
	{
		while(--j);
	} while(--i);
}
/****************************************************************/
//IO初始化函数IO_Init()，无形参，无返回值
/****************************************************************/
void IO_init(void)
{
	//配置P1.6为推挽/强上拉模式
	P1M0|=0x40;			//P1M0.6=1
	P1M1&=0xBF;			//P1M1.6=0
	//配置P3.2为准双向/弱上拉模式
	P3M0&=0xFB;			//P3M0.2=0
	P3M1&=0xFB;			//P3M1.2=0
	//配置P3.6-7为准双向/弱上拉模式
	P3M0&=0x3F;			//P3M0.6-7=0
	P3M1&=0x3F;			//P3M1.6-7=0
	//配置P1.0-3为准双向/弱上拉模式
	P1M0&=0xF0;			//P1M0.0-3=0
	P1M1&=0xF0;			//P1M1.0-3=0
	delay(10);			//等待I/O模式配置稳定
}
/********************************************************************/
//系统时钟输出函数SYSCLK_CCO()，有形参TYPE用于选择时钟源（0-外部时钟）
//（1-片内高速时钟）（2-片内低速时钟），有形参SET_F用于指定时钟源
//分频系数，有形参SET_P用于指定输出引脚的选择（P5.4/P1.6）无返回值
/********************************************************************/
void SYSCLK_CCO(u8 TYPE,u8 SET_F,u8 SET_P)
{
	P_SW2|=0x80;					//允许访问扩展特殊功能寄存器XSFR
	switch(TYPE)
	{
		case 0:
		{
			XOSCCR|=0xC0;			//使能外部晶体振荡器
			while(!(XOSCCR&0x01));//等待外部时钟稳定
			//配置MCKSEL[1:0]=“01”，选择外部时钟
			CLKSEL&=0xFD;			//清零MCKSEL[1:0]的高位
			CLKSEL|=0x01;			//配置MCKSEL[1:0]的低位
		}break;		
		case 1:							//若选择片内高速时钟，则无需配置时钟选择
		{}break;
		case 2:
		{
			IRC32KCR|=0x80;		//使能内部32kHz低速IRC控制寄存器
			while(!(IRC32KCR&0x01));//等待内部低速时钟稳定
			CLKSEL|=0x03;			//配置MCKSEL[1:0]=“11”选择内部低速IRC时钟
		}break;
	}
	switch(SET_F)
	{
		case 1:{MCLKOCR&=0x80;MCLKOCR|=0x01;}break;		//Fsysclk/1
		case 2:{MCLKOCR&=0x80;MCLKOCR|=0x02;}break;		//Fsysclk/2
		case 4:{MCLKOCR&=0x80;MCLKOCR|=0x04;}break;		//Fsysclk/4
		case 8:{MCLKOCR&=0x80;MCLKOCR|=0x08;}break;		//Fsysclk/8
		case 16:{MCLKOCR&=0x80;MCLKOCR|=0x10;}break;	//Fsysclk/16
		case 32:{MCLKOCR&=0x80;MCLKOCR|=0x20;}break;	//Fsysclk/32
		case 64:{MCLKOCR&=0x80;MCLKOCR|=0x40;}break;	//Fsysclk/64
		case 96:{MCLKOCR&=0x80;MCLKOCR|=0x60;}break;	//Fsysclk/96
		case 127:{MCLKOCR&=0x80;MCLKOCR|=0x7F;}break;	//Fsysclk/127
	}
	if(SET_P==0)
		MCLKOCR&=0x7F;			//配置时钟由P5.4引脚输出
	else
		MCLKOCR|=0x80;			//配置时钟由P1.6引脚输出
	P_SW2&=0x7F; 					//结束并关闭XSFR访问
}
/********************************************************************/
//LCD1602初始化函数LCD1602_init()，无形参和返回值
/********************************************************************/









/********************************************************************/
//显示字符函数LCD1602_DIS()，无形参和返回值
/********************************************************************/









/********************************************************************/
//写入液晶模组命令或数据函数LCD1602_Write()，有形参cmdordata
//和writetype，无返回值
/********************************************************************/






/********************************************************************/
//设定地址写入字符函数LCD1602_DIS_CHAR()，有形参x、y、z无返回值
//x表示1602液晶的行，y表示列地址，z表示欲写入的字符
/********************************************************************/








/********************************************************************/
//读卡函数Read_Card()，无形参，有返回值temp
/********************************************************************/
u32 Read_Card(void)
{
	u8 i=0;										//起始位循环控制变量
	u8 timeout;  							//超时计数变量
	u8 timeout_flag; 					//超时标志
	u8 row,col;	  						//行列变量
	u8 row_parity;  					//行校验变量
	u8 col_parity[5];					//列校验变量
	u8 M_data;								//数据位变量
	u32 temp;									//卡号变量
	u32 search=0;							//搜索次数变量
	while(1)									//进行完整的读卡过程
	{		
		//***************************************************
		if(search==10)					//若10次搜索都未发现有效数据帧
			return 0;							//则返回0
		else										//否则
		search++;								//搜索次数值自增
		timeout=0;							//超时值清零
		//***************************************************
		while(Mcode==0)					//等待接收引脚出现低电平
		{
			if(timeout==TIME_OUT)	//若超时值等于设定阈值
				break;							//直接跳出本次搜索
			else									//若超时值小于设定阈值
				timeout++;					//超时值自增
		}
		//***************************************************
		if(timeout==100)				//若超时值等于100
			continue;							//结束本次搜索
		else										//否则
			timeout=0;						//超时值清零
		//***************************************************
		delay384us();	  				//延时384us
		if(Mcode)								//开始寻找帧头起始位
		{	 
			for(i=0;i<8;i++)			//循环8次判断和处理过程
			{	  
				timeout=0;					//先把超时值清零
				while(Mcode)				//等待接收引脚为高电平
				{	
					if(timeout==TIME_OUT)		//若超时值等于设定阈值
					{	  
						timeout_flag=1;break;	//判定为超时事件，直接退出
					}
					else timeout++;		//否则超时值自增
				}	 
				delay384us();				//再延时384us，判断下一个位
				if(Mcode&&timeout_flag==0);
				//判断下一位是否为1且超时标指是否为0
				else 								//两个条件中若有其一不满足
					break;						//则直接退出			   
			}
			//***************************************************
			if(timeout_flag)			//若超时标志为1
			{	  
				timeout_flag=0;continue;//则清零标志并退出本次循环
			}
			else;
			//***************************************************
			if(i==8)//若i=8，则说明帧头已被识别，现在开始接受数据
			{	
				timeout_flag=0;			//清零超时标志
				timeout=0;					//清零超时值
				while(Mcode)				//等待接收引脚为高电平
				{  
					if(timeout==TIME_OUT)		//若超时值等于设定阈值
					{	
						timeout_flag=0;break;	//判定为超时事件，直接退出
					}
					else timeout++;		//否则超时值自增
				}	  
				if(timeout_flag)	  //若超时标志为1 
				{
					timeout_flag=0;continue;//则清零标志并退出本次循环
				}
				else; 
				//***************************************************
				//将5个列校验值清零
				col_parity[0]=col_parity[1]=col_parity[2]=0;
				col_parity[3]=col_parity[4]=0;
				for(row=0;row<11;row++)
				//循环11次，接收11行数据（4个数据位+1个行校验值）
				{
					for(col=0,row_parity=0;col<5;col++)//接收数据每5个为一行
					{
						delay384us();  			//延时384us，判断下一个数据位
						if(Mcode)
							M_data=1;					//若接收引脚高电平，则数据位为1
						else
							M_data=0;					//否则，数据位为0
						//***************************************************
						if(col<4&&row<10)		//若接收数据位在0-3列且在1-10行内
						//意思就是在有效数据区域内
						{
							temp<<=1;					//卡号变量左移1位
							temp+=(u32)M_data;//把新的数据位加到卡号变量中
						}
						else;
						//***************************************************
						row_parity+=M_data;	//将数据加到行校验变量
						col_parity[col]+=M_data;//将数据加到列校验变量
						//虽然第5列数据仅作校验，但也加上
						timeout=0;					//清零超时值
						while(Mcode==(bit)M_data)	//等待接收引脚状态为停止位
						{
							if(timeout==TIME_OUT)		//若超时值等于设定阈值
							{	
								timeout_flag=1;break;	//判定为超时事件，直接退出
							}
							else timeout++;		//否则超时值自增
						}
						if(timeout_flag)		//若超时标志为1 
							break;						//则退出本次循环
						else;
					}
					//***************************************************
					if(row<10)						//因为最后一行没有校验
																//所以要加限制
					{
						if((row_parity&0x01)||timeout_flag)
						//若校验出错或超时标识为1
						{
							temp=0;						//清零本次采集的卡号数据
							timeout_flag=1;		//置位超时标志位
							break;						//退出
						}
						else;
					}
					else;
				}
				//***************************************************
				//对最后接收的列校验进行判断并结束本次主循环
				if(timeout_flag||((col_parity[0]&0x01)&&\
					(col_parity[1]&0x01)&&(col_parity[2]&0x01)&&\
				(col_parity[3]&0x01)))
				{									//最后一列是没有校验的												 
					timeout_flag=0;	//清零超时标志位
					temp=0;					//清零本次采集的卡号数据
					continue;				//退出本次循环
				} 
				else
					return temp;		//将卡号数据返回
			}
			continue;						//退出本次循环
		}
		continue;							//退出本次循环
	}
}