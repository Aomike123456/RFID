C51 COMPILER V9.60.0.0   MAIN                                                              05/18/2025 16:18:58 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include  "STC8G.h"       //主控芯片的头文件
   2          #include  "intrins.h"     //因为要用到nop()函数故而包含此文件
   3          /************************常用数据类型定义*************************/
   4          #define u8  uint8_t
   5          #define u16 uint16_t
   6          #define u32 uint32_t
   7          typedef unsigned char    uint8_t;
   8          typedef unsigned int     uint16_t;
   9          typedef unsigned long    uint32_t;
  10          /************************端口/引脚定义区域************************/
  11          sbit Mcode=P3^2;          //曼彻斯特码输入端
  12          sbit LCDRS=P3^6;          //LCD1602数据/命令选择端口
  13          sbit LCDEN=P3^7;          //LCD1602使能信号端口
  14          #define LCDDATA  P1       //LCD1602数据端口（仅用DB4至DB7）
  15          /************************用户自定义数据区域***********************/
  16          u8 table1[]="ID:            H";//LCD1602显示十六进制卡号
  17          u8 table2[]="ID:            D";//LCD1602显示十进制卡号
  18          #define TIME_OUT  256     //最大超时阈值
  19          u8 HEX[16]={'0','1','2','3','4','5','6','7','8','9','A','B','C',\
  20          'D','E','F'};//十六进制转换字符数组
  21          /**************************函数声明区域***************************/
  22          void delay(u16 Count);    //延时函数
  23          void delay384us(void);    //384us延时函数
  24          void IO_init(void);       //IO初始化函数
  25          void SYSCLK_CCO(u8 TYPE,u8 SET_F,u8 SET_P);//系统时钟输出函数
  26          void LCD1602_Write(u8 cmdordata,u8 writetype);
  27          //写入液晶模组命令或数据函数
  28          void LCD1602_init(void);  //LCD1602初始化函数
  29          void LCD1602_DIS(void);   //显示字符函数
  30          void LCD1602_DIS_CHAR(u8 x,u8 y,u8 z);//在设定地址写入字符数据函数
  31          u32 Read_Card(void);      //读卡函数
  32          /***************************主函数区域****************************/
  33          
  34          
  35          
  36          
  37          
  38          
  39          /****************************************************************/
  40          //384us延时函数delay384us()，无形参，无返回值，这是用STC-ISP算出
  41          //来的384us延时，此延时可以不严格，但应大于256us小于512us
  42          /****************************************************************/
  43          void delay384us(void)//@12MHz
  44          {
  45   1        u8 i, j;
  46   1        _nop_();
  47   1        _nop_();
  48   1        i=6;
  49   1        j=249;
  50   1        do
  51   1        {
  52   2          while(--j);
  53   2        } while(--i);
  54   1      }
C51 COMPILER V9.60.0.0   MAIN                                                              05/18/2025 16:18:58 PAGE 2   

  55          /****************************************************************/
  56          //IO初始化函数IO_Init()，无形参，无返回值
  57          /****************************************************************/
  58          void IO_init(void)
  59          {
  60   1        //配置P1.6为推挽/强上拉模式
  61   1        P1M0|=0x40;     //P1M0.6=1
  62   1        P1M1&=0xBF;     //P1M1.6=0
  63   1        //配置P3.2为准双向/弱上拉模式
  64   1        P3M0&=0xFB;     //P3M0.2=0
  65   1        P3M1&=0xFB;     //P3M1.2=0
  66   1        //配置P3.6-7为准双向/弱上拉模式
  67   1        P3M0&=0x3F;     //P3M0.6-7=0
  68   1        P3M1&=0x3F;     //P3M1.6-7=0
  69   1        //配置P1.0-3为准双向/弱上拉模式
  70   1        P1M0&=0xF0;     //P1M0.0-3=0
  71   1        P1M1&=0xF0;     //P1M1.0-3=0
  72   1        delay(10);      //等待I/O模式配置稳定
  73   1      }
  74          /********************************************************************/
  75          //系统时钟输出函数SYSCLK_CCO()，有形参TYPE用于选择时钟源（0-外部时钟）
  76          //（1-片内高速时钟）（2-片内低速时钟），有形参SET_F用于指定时钟源
  77          //分频系数，有形参SET_P用于指定输出引脚的选择（P5.4/P1.6）无返回值
  78          /********************************************************************/
  79          void SYSCLK_CCO(u8 TYPE,u8 SET_F,u8 SET_P)
  80          {
  81   1        P_SW2|=0x80;          //允许访问扩展特殊功能寄存器XSFR
  82   1        switch(TYPE)
  83   1        {
  84   2          case 0:
  85   2          {
  86   3            XOSCCR|=0xC0;     //使能外部晶体振荡器
  87   3            while(!(XOSCCR&0x01));//等待外部时钟稳定
  88   3            //配置MCKSEL[1:0]=“01”，选择外部时钟
  89   3            CLKSEL&=0xFD;     //清零MCKSEL[1:0]的高位
  90   3            CLKSEL|=0x01;     //配置MCKSEL[1:0]的低位
  91   3          }break;   
  92   2          case 1:             //若选择片内高速时钟，则无需配置时钟选择
  93   2          {}break;
  94   2          case 2:
  95   2          {
  96   3            IRC32KCR|=0x80;   //使能内部32kHz低速IRC控制寄存器
  97   3            while(!(IRC32KCR&0x01));//等待内部低速时钟稳定
  98   3            CLKSEL|=0x03;     //配置MCKSEL[1:0]=“11”选择内部低速IRC时钟
  99   3          }break;
 100   2        }
 101   1        switch(SET_F)
 102   1        {
 103   2          case 1:{MCLKOCR&=0x80;MCLKOCR|=0x01;}break;   //Fsysclk/1
 104   2          case 2:{MCLKOCR&=0x80;MCLKOCR|=0x02;}break;   //Fsysclk/2
 105   2          case 4:{MCLKOCR&=0x80;MCLKOCR|=0x04;}break;   //Fsysclk/4
 106   2          case 8:{MCLKOCR&=0x80;MCLKOCR|=0x08;}break;   //Fsysclk/8
 107   2          case 16:{MCLKOCR&=0x80;MCLKOCR|=0x10;}break;  //Fsysclk/16
 108   2          case 32:{MCLKOCR&=0x80;MCLKOCR|=0x20;}break;  //Fsysclk/32
 109   2          case 64:{MCLKOCR&=0x80;MCLKOCR|=0x40;}break;  //Fsysclk/64
 110   2          case 96:{MCLKOCR&=0x80;MCLKOCR|=0x60;}break;  //Fsysclk/96
 111   2          case 127:{MCLKOCR&=0x80;MCLKOCR|=0x7F;}break; //Fsysclk/127
 112   2        }
 113   1        if(SET_P==0)
 114   1          MCLKOCR&=0x7F;      //配置时钟由P5.4引脚输出
 115   1        else
 116   1          MCLKOCR|=0x80;      //配置时钟由P1.6引脚输出
C51 COMPILER V9.60.0.0   MAIN                                                              05/18/2025 16:18:58 PAGE 3   

 117   1        P_SW2&=0x7F;          //结束并关闭XSFR访问
 118   1      }
 119          /********************************************************************/
 120          //LCD1602初始化函数LCD1602_init()，无形参和返回值
 121          /********************************************************************/
 122          
 123          
 124          
 125          
 126          
 127          
 128          
 129          
 130          
 131          /********************************************************************/
 132          //显示字符函数LCD1602_DIS()，无形参和返回值
 133          /********************************************************************/
 134          
 135          
 136          
 137          
 138          
 139          
 140          
 141          
 142          
 143          /********************************************************************/
 144          //写入液晶模组命令或数据函数LCD1602_Write()，有形参cmdordata
 145          //和writetype，无返回值
 146          /********************************************************************/
 147          
 148          
 149          
 150          
 151          
 152          
 153          /********************************************************************/
 154          //设定地址写入字符函数LCD1602_DIS_CHAR()，有形参x、y、z无返回值
 155          //x表示1602液晶的行，y表示列地址，z表示欲写入的字符
 156          /********************************************************************/
 157          
 158          
 159          
 160          
 161          
 162          
 163          
 164          
 165          /********************************************************************/
 166          //读卡函数Read_Card()，无形参，有返回值temp
 167          /********************************************************************/
 168          u32 Read_Card(void)
 169          {
 170   1        u8 i=0;                   //起始位循环控制变量
 171   1        u8 timeout;               //超时计数变量
 172   1        u8 timeout_flag;          //超时标志
 173   1        u8 row,col;               //行列变量
 174   1        u8 row_parity;            //行校验变量
 175   1        u8 col_parity[5];         //列校验变量
 176   1        u8 M_data;                //数据位变量
 177   1        u32 temp;                 //卡号变量
 178   1        u32 search=0;             //搜索次数变量
C51 COMPILER V9.60.0.0   MAIN                                                              05/18/2025 16:18:58 PAGE 4   

 179   1        while(1)                  //进行完整的读卡过程
 180   1        {   
 181   2          //***************************************************
 182   2          if(search==10)          //若10次搜索都未发现有效数据帧
 183   2            return 0;             //则返回0
 184   2          else                    //否则
 185   2          search++;               //搜索次数值自增
 186   2          timeout=0;              //超时值清零
 187   2          //***************************************************
 188   2          while(Mcode==0)         //等待接收引脚出现低电平
 189   2          {
 190   3            if(timeout==TIME_OUT) //若超时值等于设定阈值
 191   3              break;              //直接跳出本次搜索
 192   3            else                  //若超时值小于设定阈值
 193   3              timeout++;          //超时值自增
 194   3          }
 195   2          //***************************************************
 196   2          if(timeout==100)        //若超时值等于100
 197   2            continue;             //结束本次搜索
 198   2          else                    //否则
 199   2            timeout=0;            //超时值清零
 200   2          //***************************************************
 201   2          delay384us();           //延时384us
 202   2          if(Mcode)               //开始寻找帧头起始位
 203   2          {  
 204   3            for(i=0;i<8;i++)      //循环8次判断和处理过程
 205   3            {   
 206   4              timeout=0;          //先把超时值清零
 207   4              while(Mcode)        //等待接收引脚为高电平
 208   4              { 
 209   5                if(timeout==TIME_OUT)   //若超时值等于设定阈值
 210   5                {   
 211   6                  timeout_flag=1;break; //判定为超时事件，直接退出
 212   6                }
 213   5                else timeout++;   //否则超时值自增
 214   5              }  
 215   4              delay384us();       //再延时384us，判断下一个位
 216   4              if(Mcode&&timeout_flag==0);
 217   4              //判断下一位是否为1且超时标指是否为0
 218   4              else                //两个条件中若有其一不满足
 219   4                break;            //则直接退出         
 220   4            }
 221   3            //***************************************************
 222   3            if(timeout_flag)      //若超时标志为1
 223   3            {   
 224   4              timeout_flag=0;continue;//则清零标志并退出本次循环
 225   4            }
 226   3            else;
 227   3            //***************************************************
 228   3            if(i==8)//若i=8，则说明帧头已被识别，现在开始接受数据
 229   3            { 
 230   4              timeout_flag=0;     //清零超时标志
 231   4              timeout=0;          //清零超时值
 232   4              while(Mcode)        //等待接收引脚为高电平
 233   4              {  
 234   5                if(timeout==TIME_OUT)   //若超时值等于设定阈值
 235   5                { 
 236   6                  timeout_flag=0;break; //判定为超时事件，直接退出
 237   6                }
 238   5                else timeout++;   //否则超时值自增
 239   5              }   
 240   4              if(timeout_flag)    //若超时标志为1 
C51 COMPILER V9.60.0.0   MAIN                                                              05/18/2025 16:18:58 PAGE 5   

 241   4              {
 242   5                timeout_flag=0;continue;//则清零标志并退出本次循环
 243   5              }
 244   4              else; 
 245   4              //***************************************************
 246   4              //将5个列校验值清零
 247   4              col_parity[0]=col_parity[1]=col_parity[2]=0;
 248   4              col_parity[3]=col_parity[4]=0;
 249   4              for(row=0;row<11;row++)
 250   4              //循环11次，接收11行数据（4个数据位+1个行校验值）
 251   4              {
 252   5                for(col=0,row_parity=0;col<5;col++)//接收数据每5个为一行
 253   5                {
 254   6                  delay384us();       //延时384us，判断下一个数据位
 255   6                  if(Mcode)
 256   6                    M_data=1;         //若接收引脚高电平，则数据位为1
 257   6                  else
 258   6                    M_data=0;         //否则，数据位为0
 259   6                  //***************************************************
 260   6                  if(col<4&&row<10)   //若接收数据位在0-3列且在1-10行内
 261   6                  //意思就是在有效数据区域内
 262   6                  {
 263   7                    temp<<=1;         //卡号变量左移1位
 264   7                    temp+=(u32)M_data;//把新的数据位加到卡号变量中
 265   7                  }
 266   6                  else;
 267   6                  //***************************************************
 268   6                  row_parity+=M_data; //将数据加到行校验变量
 269   6                  col_parity[col]+=M_data;//将数据加到列校验变量
 270   6                  //虽然第5列数据仅作校验，但也加上
 271   6                  timeout=0;          //清零超时值
 272   6                  while(Mcode==(bit)M_data) //等待接收引脚状态为停止位
 273   6                  {
 274   7                    if(timeout==TIME_OUT)   //若超时值等于设定阈值
 275   7                    { 
 276   8                      timeout_flag=1;break; //判定为超时事件，直接退出
 277   8                    }
 278   7                    else timeout++;   //否则超时值自增
 279   7                  }
 280   6                  if(timeout_flag)    //若超时标志为1 
 281   6                    break;            //则退出本次循环
 282   6                  else;
 283   6                }
 284   5                //***************************************************
 285   5                if(row<10)            //因为最后一行没有校验
 286   5                                      //所以要加限制
 287   5                {
 288   6                  if((row_parity&0x01)||timeout_flag)
 289   6                  //若校验出错或超时标识为1
 290   6                  {
 291   7                    temp=0;           //清零本次采集的卡号数据
 292   7                    timeout_flag=1;   //置位超时标志位
 293   7                    break;            //退出
 294   7                  }
 295   6                  else;
 296   6                }
 297   5                else;
 298   5              }
 299   4              //***************************************************
 300   4              //对最后接收的列校验进行判断并结束本次主循环
 301   4              if(timeout_flag||((col_parity[0]&0x01)&&\
 302   4                (col_parity[1]&0x01)&&(col_parity[2]&0x01)&&\
C51 COMPILER V9.60.0.0   MAIN                                                              05/18/2025 16:18:58 PAGE 6   

 303   4              (col_parity[3]&0x01)))
 304   4              {                 //最后一列是没有校验的                         
 305   5                timeout_flag=0; //清零超时标志位
 306   5                temp=0;         //清零本次采集的卡号数据
 307   5                continue;       //退出本次循环
 308   5              } 
 309   4              else
 310   4                return temp;    //将卡号数据返回
 311   4            }
 312   3            continue;           //退出本次循环
 313   3          }
 314   2          continue;             //退出本次循环
 315   2        }
 316   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    717    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     50      18
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
