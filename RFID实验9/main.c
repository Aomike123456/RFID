/******************************************************************
 * 实验名称：液晶显示Manchester解码实验
 * 可配书籍：上册-《深入浅出STC8增强型51单片机进阶攻略》已经出版
						 下册-《深入浅出STC8增强型51单片机实战攻略》还在写作
 * 书籍备注：龙顺宇编著 清华大学出版社出版
 * 淘宝店铺：https://520mcu.taobao.com/
 * 实验平台：思修电子工作室SX-RFID-B低频ID识别与应用开发板 Long
 * 芯片型号：STC8G1K08/17（微调后可移植至STC8A/F/C/G/H系列单片机）
 * 时钟说明：芯片内部12MHz，在使用STC-ISP软件时需要先配置然后下载
 *           到单片机使得时钟配置生效。
 * 实验说明：断电前提下向开发板插入1602液晶模块，然后用USB线插入
 Uart-USB接口给开发板供电，做好STC-ISP配置并下载程序，观察1602液
 晶的显示情况（第一行默认显示“ID:H”，第二行默认显示“ID:H”）,我们
 在开发板上方5-15cm处放置卡片，此时液晶的第一行会显示出十六进制卡
 号，第二行会显示出十进制卡号，以此学习Manchester解码方法和进制转
 换、取位等方法。
******************************************************************/
#include	"STC8G.h"				//主控芯片的头文件
#include  "intrins.h"			//因为要用到nop()函数故而包含此文件
/************************常用数据类型定义*************************/
#define u8  uint8_t
#define u16 uint16_t
#define u32 uint32_t
typedef unsigned char    uint8_t;
typedef unsigned int     uint16_t;
typedef unsigned long    uint32_t;
/************************端口/引脚定义区域************************/
sbit Mcode=P3^2;  				//曼彻斯特码输入端
sbit LCDRS=P3^6;    			//LCD1602数据/命令选择端口
sbit LCDEN=P3^7;     			//LCD1602使能信号端口
#define LCDDATA  P1  			//LCD1602数据端口（仅用DB4至DB7）
/************************用户自定义数据区域***********************/
u8 table1[]="ID:            H";//LCD1602显示十六进制卡号
u8 table2[]="ID:            D";//LCD1602显示十进制卡号
#define TIME_OUT  256			//最大超时阈值
u8 HEX[16]={'0','1','2','3','4','5','6','7','8','9','A','B','C',\
'D','E','F'};//十六进制转换字符数组
/**************************函数声明区域***************************/
void delay(u16 Count);		//延时函数
void delay384us(void);		//384us延时函数
void IO_init(void);   		//IO初始化函数
void SYSCLK_CCO(u8 TYPE,u8 SET_F,u8 SET_P);//系统时钟输出函数
void LCD1602_Write(u8 cmdordata,u8 writetype);
//写入液晶模组命令或数据函数
void LCD1602_init(void);	//LCD1602初始化函数
void LCD1602_DIS(void);		//显示字符函数
void LCD1602_DIS_CHAR(u8 x,u8 y,u8 z);//在设定地址写入字符数据函数
u32 Read_Card(void);			//读卡函数
/***************************主函数区域****************************/
void main(void)
{
 	u32 SN=0;								//定义卡号接收变量
	IO_init();							//IO初始化	
	SYSCLK_CCO(1,96,1);			//P1.6输出96分频的内部高速时钟12M/96=125kHz
	LCDEN=1;delay(200);			//使能置“1”（防止复位乱码）
	LCDEN=0;delay(200);			//使能清“0”（防止复位乱码）
	LCD1602_init(); 				//LCD1602初始化
	delay(200);							//延时等待稳定
  LCD1602_DIS();  				//显示字符效果
	while(1)
	{
		SN=Read_Card();				//读取卡号数据
		if(SN)								//若卡号不为0，即有效卡号
		{
			//显示十六进制形式卡号
			LCD1602_DIS_CHAR(1,4,HEX[SN/16/16/16/16/16/16/16%16]);
			LCD1602_DIS_CHAR(1,5,HEX[SN/16/16/16/16/16/16%16]);
			LCD1602_DIS_CHAR(1,6,HEX[SN/16/16/16/16/16%16]);
			LCD1602_DIS_CHAR(1,7,HEX[SN/16/16/16/16%16]);
			LCD1602_DIS_CHAR(1,8,HEX[SN/16/16/16%16]);
			LCD1602_DIS_CHAR(1,9,HEX[SN/16/16%16]);
			LCD1602_DIS_CHAR(1,10,HEX[SN/16%16]);
			LCD1602_DIS_CHAR(1,11,HEX[SN%16]);
			//显示十进制形式卡号
			LCD1602_DIS_CHAR(2,4,SN/1000000000+0x30);
			LCD1602_DIS_CHAR(2,5,SN%1000000000/100000000+0x30);
			LCD1602_DIS_CHAR(2,6,SN%100000000/10000000+0x30);
			LCD1602_DIS_CHAR(2,7,SN%10000000/1000000+0x30);
			LCD1602_DIS_CHAR(2,8,SN%1000000/100000+0x30);
			LCD1602_DIS_CHAR(2,9,SN%100000/10000+0x30);
			LCD1602_DIS_CHAR(2,10,SN%10000/1000+0x30);
			LCD1602_DIS_CHAR(2,11,SN%1000/100+0x30);
			LCD1602_DIS_CHAR(2,12,SN%100/10+0x30);
			LCD1602_DIS_CHAR(2,13,SN%10+0x30);
		}
	}
}
/****************************************************************/
//延时函数delay()，有形参Count用于控制延时函数执行次数，无返回值
/****************************************************************/
void delay(u16 Count)
{
  u8 i,j;
  while (Count--)
  {
    for(i=0;i<50;i++)
      for(j=0;j<20;j++);
  }
}
/****************************************************************/
//384us延时函数delay384us()，无形参，无返回值，这是用STC-ISP算出
//来的384us延时，此延时可以不严格，但应大于256us小于512us
/****************************************************************/
void delay384us(void)//@12MHz
{
	u8 i, j;
	_nop_();
	_nop_();
	i=6;
	j=249;
	do
	{
		while(--j);
	} while(--i);
}
/****************************************************************/
//IO初始化函数IO_Init()，无形参，无返回值
/****************************************************************/
void IO_init(void)
{
	//配置P1.6为推挽/强上拉模式
	P1M0|=0x40;			//P1M0.6=1
	P1M1&=0xBF;			//P1M1.6=0
	//配置P3.2为准双向/弱上拉模式
	P3M0&=0xFB;			//P3M0.2=0
	P3M1&=0xFB;			//P3M1.2=0
	//配置P3.6-7为准双向/弱上拉模式
	P3M0&=0x3F;			//P3M0.6-7=0
	P3M1&=0x3F;			//P3M1.6-7=0
	//配置P1.0-3为准双向/弱上拉模式
	P1M0&=0xF0;			//P1M0.0-3=0
	P1M1&=0xF0;			//P1M1.0-3=0
	delay(10);			//等待I/O模式配置稳定
}
/********************************************************************/
//系统时钟输出函数SYSCLK_CCO()，有形参TYPE用于选择时钟源（0-外部时钟）
//（1-片内高速时钟）（2-片内低速时钟），有形参SET_F用于指定时钟源
//分频系数，有形参SET_P用于指定输出引脚的选择（P5.4/P1.6）无返回值
/********************************************************************/
void SYSCLK_CCO(u8 TYPE,u8 SET_F,u8 SET_P)
{
	P_SW2|=0x80;					//允许访问扩展特殊功能寄存器XSFR
	switch(TYPE)
	{
		case 0:
		{
			XOSCCR|=0xC0;			//使能外部晶体振荡器
			while(!(XOSCCR&0x01));//等待外部时钟稳定
			//配置MCKSEL[1:0]=“01”，选择外部时钟
			CLKSEL&=0xFD;			//清零MCKSEL[1:0]的高位
			CLKSEL|=0x01;			//配置MCKSEL[1:0]的低位
		}break;		
		case 1:							//若选择片内高速时钟，则无需配置时钟选择
		{}break;
		case 2:
		{
			IRC32KCR|=0x80;		//使能内部32kHz低速IRC控制寄存器
			while(!(IRC32KCR&0x01));//等待内部低速时钟稳定
			CLKSEL|=0x03;			//配置MCKSEL[1:0]=“11”选择内部低速IRC时钟
		}break;
	}
	switch(SET_F)
	{
		case 1:{MCLKOCR&=0x80;MCLKOCR|=0x01;}break;		//Fsysclk/1
		case 2:{MCLKOCR&=0x80;MCLKOCR|=0x02;}break;		//Fsysclk/2
		case 4:{MCLKOCR&=0x80;MCLKOCR|=0x04;}break;		//Fsysclk/4
		case 8:{MCLKOCR&=0x80;MCLKOCR|=0x08;}break;		//Fsysclk/8
		case 16:{MCLKOCR&=0x80;MCLKOCR|=0x10;}break;	//Fsysclk/16
		case 32:{MCLKOCR&=0x80;MCLKOCR|=0x20;}break;	//Fsysclk/32
		case 64:{MCLKOCR&=0x80;MCLKOCR|=0x40;}break;	//Fsysclk/64
		case 96:{MCLKOCR&=0x80;MCLKOCR|=0x60;}break;	//Fsysclk/96
		case 127:{MCLKOCR&=0x80;MCLKOCR|=0x7F;}break;	//Fsysclk/127
	}
	if(SET_P==0)
		MCLKOCR&=0x7F;			//配置时钟由P5.4引脚输出
	else
		MCLKOCR|=0x80;			//配置时钟由P1.6引脚输出
	P_SW2&=0x7F; 					//结束并关闭XSFR访问
}
/********************************************************************/
//LCD1602初始化函数LCD1602_init()，无形参和返回值
/********************************************************************/
void LCD1602_init(void)
{
	LCD1602_Write(0x28,0);delay(10);//数据总线为4位，显示2行，5*7点阵/每字符
	LCDEN=1;delay(10);							//使能置“1”
	LCDEN=0;delay(10);							//使能清“0”
	LCD1602_Write(0x0C,0);delay(10);//设置开显示，不显示光标
	LCD1602_Write(0x06,0);delay(10);//写入新数据后显示屏整体不移动仅光标右移
	LCD1602_Write(0x01,0);delay(10);//写入清屏命令
}
/********************************************************************/
//显示字符函数LCD1602_DIS()，无形参和返回值
/********************************************************************/
void LCD1602_DIS(void)
{
  u8 i;									//定义控制循环变量i
  LCD1602_Write(0x80,0);//选择第一行
	delay(5);							//延时等待1602稳定
  for(i=0;i<16;i++)
  {
      LCD1602_Write(table1[i],1);//写入table1[]内容
      delay(1);
  }
  LCD1602_Write(0xC0,0);//选择第二行
	delay(5);							//延时等待1602稳定
  for(i=0;i<16;i++)
  {
      LCD1602_Write(table2[i],1);//写入table2[]内容
      delay(1);
  }
}
/********************************************************************/
//写入液晶模组命令或数据函数LCD1602_Write()，有形参cmdordata
//和writetype，无返回值
/********************************************************************/
void LCD1602_Write(u8 cmdordata,u8 writetype)
{
	u8 temp=0;								//定义数据处理中间变量
	LCDRS=writetype;					//判断写入类型0为命令1为数据
	delay(2);									//延时等待稳定
	LCDDATA&=0xF0;						//清数据引脚
	temp=cmdordata>>4;				//高四位移到低四位
	LCDDATA|=temp&0x0F;				//写高四位
	LCDEN=1;delay(2);					//使能置“1”
	LCDEN=0;delay(2);					//使能清“0”
	LCDDATA&=0xF0;						//清数据引脚
	LCDDATA|=cmdordata&0x0F;	//写低四位
	LCDEN=1;delay(2);					//使能置“1”
	LCDEN=0;delay(2);					//使能清“0”
}
/********************************************************************/
//设定地址写入字符函数LCD1602_DIS_CHAR()，有形参x、y、z无返回值
//x表示1602液晶的行，y表示列地址，z表示欲写入的字符
/********************************************************************/
void LCD1602_DIS_CHAR(u8 x,u8 y,u8 z)
{
  u8 address;
  if(x==1)						//若欲显示在第一行
    address=0x80+y;		//第一行的行首地址+列地址
  else
    address=0xC0+y;		//第二行的行首地址+列地址
  LCD1602_Write(address,0);		//设定显示地址
  LCD1602_Write(z,1);	//写入字符数据
}
/********************************************************************/
//读卡函数Read_Card()，无形参，有返回值temp
/********************************************************************/
u32 Read_Card(void)
{
	u8 i=0;										//起始位循环控制变量
	u8 timeout;  							//超时计数变量
	u8 timeout_flag; 					//超时标志
	u8 row,col;	  						//行列变量
	u8 row_parity;  					//行校验变量
	u8 col_parity[5];					//列校验变量
	u8 M_data;								//数据位变量
	u32 temp;									//卡号变量
	u32 search=0;							//搜索次数变量
	while(1)									//进行完整的读卡过程
	{		
		//***************************************************
		if(search==10)					//若10次搜索都未发现有效数据帧
			return 0;							//则返回0
		else										//否则
		search++;								//搜索次数值自增
		timeout=0;							//超时值清零
		//***************************************************
		while(Mcode==0)					//等待接收引脚出现低电平
		{
			if(timeout==TIME_OUT)	//若超时值等于设定阈值
				break;							//直接跳出本次搜索
			else									//若超时值小于设定阈值
				timeout++;					//超时值自增
		}
		//***************************************************
		if(timeout==100)				//若超时值等于100
			continue;							//结束本次搜索
		else										//否则
			timeout=0;						//超时值清零
		//***************************************************
		delay384us();	  				//延时384us
		if(Mcode)								//开始寻找帧头起始位
		{	 
			for(i=0;i<8;i++)			//循环8次判断和处理过程
			{	  
				timeout=0;					//先把超时值清零
				while(Mcode)				//等待接收引脚为高电平
				{	
					if(timeout==TIME_OUT)		//若超时值等于设定阈值
					{	  
						timeout_flag=1;break;	//判定为超时事件，直接退出
					}
					else timeout++;		//否则超时值自增
				}	 
				delay384us();				//再延时384us，判断下一个位
				if(Mcode&&timeout_flag==0);
				//判断下一位是否为1且超时标指是否为0
				else 								//两个条件中若有其一不满足
					break;						//则直接退出			   
			}
			//***************************************************
			if(timeout_flag)			//若超时标志为1
			{	  
				timeout_flag=0;continue;//则清零标志并退出本次循环
			}
			else;
			//***************************************************
			if(i==8)//若i=8，则说明帧头已被识别，现在开始接受数据
			{	
				timeout_flag=0;			//清零超时标志
				timeout=0;					//清零超时值
				while(Mcode)				//等待接收引脚为高电平
				{  
					if(timeout==TIME_OUT)		//若超时值等于设定阈值
					{	
						timeout_flag=0;break;	//判定为超时事件，直接退出
					}
					else timeout++;		//否则超时值自增
				}	  
				if(timeout_flag)	  //若超时标志为1 
				{
					timeout_flag=0;continue;//则清零标志并退出本次循环
				}
				else; 
				//***************************************************
				//将5个列校验值清零
				col_parity[0]=col_parity[1]=col_parity[2]=0;
				col_parity[3]=col_parity[4]=0;
				for(row=0;row<11;row++)
				//循环11次，接收11行数据（4个数据位+1个行校验值）
				{
					for(col=0,row_parity=0;col<5;col++)//接收数据每5个为一行
					{
						delay384us();  			//延时384us，判断下一个数据位
						if(Mcode)
							M_data=1;					//若接收引脚高电平，则数据位为1
						else
							M_data=0;					//否则，数据位为0
						//***************************************************
						if(col<4&&row<10)		//若接收数据位在0-3列且在1-10行内
						//意思就是在有效数据区域内
						{
							temp<<=1;					//卡号变量左移1位
							temp+=(u32)M_data;//把新的数据位加到卡号变量中
						}
						else;
						//***************************************************
						row_parity+=M_data;	//将数据加到行校验变量
						col_parity[col]+=M_data;//将数据加到列校验变量
						//虽然第5列数据仅作校验，但也加上
						timeout=0;					//清零超时值
						while(Mcode==(bit)M_data)	//等待接收引脚状态为停止位
						{
							if(timeout==TIME_OUT)		//若超时值等于设定阈值
							{	
								timeout_flag=1;break;	//判定为超时事件，直接退出
							}
							else timeout++;		//否则超时值自增
						}
						if(timeout_flag)		//若超时标志为1 
							break;						//则退出本次循环
						else;
					}
					//***************************************************
					if(row<10)						//因为最后一行没有校验
																//所以要加限制
					{
						if((row_parity&0x01)||timeout_flag)
						//若校验出错或超时标识为1
						{
							temp=0;						//清零本次采集的卡号数据
							timeout_flag=1;		//置位超时标志位
							break;						//退出
						}
						else;
					}
					else;
				}
				//***************************************************
				//对最后接收的列校验进行判断并结束本次主循环
				if(timeout_flag||((col_parity[0]&0x01)&&\
					(col_parity[1]&0x01)&&(col_parity[2]&0x01)&&\
				(col_parity[3]&0x01)))
				{									//最后一列是没有校验的												 
					timeout_flag=0;	//清零超时标志位
					temp=0;					//清零本次采集的卡号数据
					continue;				//退出本次循环
				} 
				else
					return temp;		//将卡号数据返回
			}
			continue;						//退出本次循环
		}
		continue;							//退出本次循环
	}
}