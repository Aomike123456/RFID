C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:42:17 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /******************************************************************
   2           * 实验名称：液晶显示Manchester解码实验
   3           * 可配书籍：上册-《深入浅出STC8增强型51单片机进阶攻略》已经出版
   4                       下册-《深入浅出STC8增强型51单片机实战攻略》还在写作
   5           * 书籍备注：龙顺宇编著 清华大学出版社出版
   6           * 淘宝店铺：https://520mcu.taobao.com/
   7           * 实验平台：思修电子工作室SX-RFID-B低频ID识别与应用开发板 Long
   8           * 芯片型号：STC8G1K08/17（微调后可移植至STC8A/F/C/G/H系列单片机）
   9           * 时钟说明：芯片内部12MHz，在使用STC-ISP软件时需要先配置然后下载
  10           *           到单片机使得时钟配置生效。
  11           * 实验说明：断电前提下向开发板插入1602液晶模块，然后用USB线插入
  12           Uart-USB接口给开发板供电，做好STC-ISP配置并下载程序，观察1602液
  13           晶的显示情况（第一行默认显示“ID:H”，第二行默认显示“ID:H”）,我们
  14           在开发板上方5-15cm处放置卡片，此时液晶的第一行会显示出十六进制卡
  15           号，第二行会显示出十进制卡号，以此学习Manchester解码方法和进制转
  16           换、取位等方法。
  17          ******************************************************************/
  18          #include  "STC8G.h"       //主控芯片的头文件
  19          #include  "intrins.h"     //因为要用到nop()函数故而包含此文件
  20          /************************常用数据类型定义*************************/
  21          #define u8  uint8_t
  22          #define u16 uint16_t
  23          #define u32 uint32_t
  24          typedef unsigned char    uint8_t;
  25          typedef unsigned int     uint16_t;
  26          typedef unsigned long    uint32_t;
  27          /************************端口/引脚定义区域************************/
  28          sbit Mcode=P3^2;          //曼彻斯特码输入端
  29          sbit LCDRS=P3^6;          //LCD1602数据/命令选择端口
  30          sbit LCDEN=P3^7;          //LCD1602使能信号端口
  31          #define LCDDATA  P1       //LCD1602数据端口（仅用DB4至DB7）
  32          /************************用户自定义数据区域***********************/
  33          u8 table1[]="ID:            H";//LCD1602显示十六进制卡号
  34          u8 table2[]="ID:            D";//LCD1602显示十进制卡号
  35          #define TIME_OUT  256     //最大超时阈值
  36          u8 HEX[16]={'0','1','2','3','4','5','6','7','8','9','A','B','C',\
  37          'D','E','F'};//十六进制转换字符数组
  38          /**************************函数声明区域***************************/
  39          void delay(u16 Count);    //延时函数
  40          void delay384us(void);    //384us延时函数
  41          void IO_init(void);       //IO初始化函数
  42          void SYSCLK_CCO(u8 TYPE,u8 SET_F,u8 SET_P);//系统时钟输出函数
  43          void LCD1602_Write(u8 cmdordata,u8 writetype);
  44          //写入液晶模组命令或数据函数
  45          void LCD1602_init(void);  //LCD1602初始化函数
  46          void LCD1602_DIS(void);   //显示字符函数
  47          void LCD1602_DIS_CHAR(u8 x,u8 y,u8 z);//在设定地址写入字符数据函数
  48          u32 Read_Card(void);      //读卡函数
  49          /***************************主函数区域****************************/
  50          void main(void)
  51          {
  52   1        u32 SN=0;               //定义卡号接收变量
  53   1        IO_init();              //IO初始化  
  54   1        SYSCLK_CCO(1,96,1);     //P1.6输出96分频的内部高速时钟12M/96=125kHz
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:42:17 PAGE 2   

  55   1        LCDEN=1;delay(200);     //使能置“1”（防止复位乱码）
  56   1        LCDEN=0;delay(200);     //使能清“0”（防止复位乱码）
  57   1        LCD1602_init();         //LCD1602初始化
  58   1        delay(200);             //延时等待稳定
  59   1        LCD1602_DIS();          //显示字符效果
  60   1        while(1)
  61   1        {
  62   2          SN=Read_Card();       //读取卡号数据
  63   2          if(SN)                //若卡号不为0，即有效卡号
  64   2          {
  65   3            //显示十六进制形式卡号
  66   3            LCD1602_DIS_CHAR(1,4,HEX[SN/16/16/16/16/16/16/16%16]);
  67   3            LCD1602_DIS_CHAR(1,5,HEX[SN/16/16/16/16/16/16%16]);
  68   3            LCD1602_DIS_CHAR(1,6,HEX[SN/16/16/16/16/16%16]);
  69   3            LCD1602_DIS_CHAR(1,7,HEX[SN/16/16/16/16%16]);
  70   3            LCD1602_DIS_CHAR(1,8,HEX[SN/16/16/16%16]);
  71   3            LCD1602_DIS_CHAR(1,9,HEX[SN/16/16%16]);
  72   3            LCD1602_DIS_CHAR(1,10,HEX[SN/16%16]);
  73   3            LCD1602_DIS_CHAR(1,11,HEX[SN%16]);
  74   3            //显示十进制形式卡号
  75   3            LCD1602_DIS_CHAR(2,4,SN/1000000000+0x30);
  76   3            LCD1602_DIS_CHAR(2,5,SN%1000000000/100000000+0x30);
  77   3            LCD1602_DIS_CHAR(2,6,SN%100000000/10000000+0x30);
  78   3            LCD1602_DIS_CHAR(2,7,SN%10000000/1000000+0x30);
  79   3            LCD1602_DIS_CHAR(2,8,SN%1000000/100000+0x30);
  80   3            LCD1602_DIS_CHAR(2,9,SN%100000/10000+0x30);
  81   3            LCD1602_DIS_CHAR(2,10,SN%10000/1000+0x30);
  82   3            LCD1602_DIS_CHAR(2,11,SN%1000/100+0x30);
  83   3            LCD1602_DIS_CHAR(2,12,SN%100/10+0x30);
  84   3            LCD1602_DIS_CHAR(2,13,SN%10+0x30);
  85   3          }
  86   2        }
  87   1      }
  88          /****************************************************************/
  89          //延时函数delay()，有形参Count用于控制延时函数执行次数，无返回值
  90          /****************************************************************/
  91          void delay(u16 Count)
  92          {
  93   1        u8 i,j;
  94   1        while (Count--)
  95   1        {
  96   2          for(i=0;i<50;i++)
  97   2            for(j=0;j<20;j++);
  98   2        }
  99   1      }
 100          /****************************************************************/
 101          //384us延时函数delay384us()，无形参，无返回值，这是用STC-ISP算出
 102          //来的384us延时，此延时可以不严格，但应大于256us小于512us
 103          /****************************************************************/
 104          void delay384us(void)//@12MHz
 105          {
 106   1        u8 i, j;
 107   1        _nop_();
 108   1        _nop_();
 109   1        i=6;
 110   1        j=249;
 111   1        do
 112   1        {
 113   2          while(--j);
 114   2        } while(--i);
 115   1      }
 116          /****************************************************************/
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:42:17 PAGE 3   

 117          //IO初始化函数IO_Init()，无形参，无返回值
 118          /****************************************************************/
 119          void IO_init(void)
 120          {
 121   1        //配置P1.6为推挽/强上拉模式
 122   1        P1M0|=0x40;     //P1M0.6=1
 123   1        P1M1&=0xBF;     //P1M1.6=0
 124   1        //配置P3.2为准双向/弱上拉模式
 125   1        P3M0&=0xFB;     //P3M0.2=0
 126   1        P3M1&=0xFB;     //P3M1.2=0
 127   1        //配置P3.6-7为准双向/弱上拉模式
 128   1        P3M0&=0x3F;     //P3M0.6-7=0
 129   1        P3M1&=0x3F;     //P3M1.6-7=0
 130   1        //配置P1.0-3为准双向/弱上拉模式
 131   1        P1M0&=0xF0;     //P1M0.0-3=0
 132   1        P1M1&=0xF0;     //P1M1.0-3=0
 133   1        delay(10);      //等待I/O模式配置稳定
 134   1      }
 135          /********************************************************************/
 136          //系统时钟输出函数SYSCLK_CCO()，有形参TYPE用于选择时钟源（0-外部时钟）
 137          //（1-片内高速时钟）（2-片内低速时钟），有形参SET_F用于指定时钟源
 138          //分频系数，有形参SET_P用于指定输出引脚的选择（P5.4/P1.6）无返回值
 139          /********************************************************************/
 140          void SYSCLK_CCO(u8 TYPE,u8 SET_F,u8 SET_P)
 141          {
 142   1        P_SW2|=0x80;          //允许访问扩展特殊功能寄存器XSFR
 143   1        switch(TYPE)
 144   1        {
 145   2          case 0:
 146   2          {
 147   3            XOSCCR|=0xC0;     //使能外部晶体振荡器
 148   3            while(!(XOSCCR&0x01));//等待外部时钟稳定
 149   3            //配置MCKSEL[1:0]=“01”，选择外部时钟
 150   3            CLKSEL&=0xFD;     //清零MCKSEL[1:0]的高位
 151   3            CLKSEL|=0x01;     //配置MCKSEL[1:0]的低位
 152   3          }break;   
 153   2          case 1:             //若选择片内高速时钟，则无需配置时钟选择
 154   2          {}break;
 155   2          case 2:
 156   2          {
 157   3            IRC32KCR|=0x80;   //使能内部32kHz低速IRC控制寄存器
 158   3            while(!(IRC32KCR&0x01));//等待内部低速时钟稳定
 159   3            CLKSEL|=0x03;     //配置MCKSEL[1:0]=“11”选择内部低速IRC时钟
 160   3          }break;
 161   2        }
 162   1        switch(SET_F)
 163   1        {
 164   2          case 1:{MCLKOCR&=0x80;MCLKOCR|=0x01;}break;   //Fsysclk/1
 165   2          case 2:{MCLKOCR&=0x80;MCLKOCR|=0x02;}break;   //Fsysclk/2
 166   2          case 4:{MCLKOCR&=0x80;MCLKOCR|=0x04;}break;   //Fsysclk/4
 167   2          case 8:{MCLKOCR&=0x80;MCLKOCR|=0x08;}break;   //Fsysclk/8
 168   2          case 16:{MCLKOCR&=0x80;MCLKOCR|=0x10;}break;  //Fsysclk/16
 169   2          case 32:{MCLKOCR&=0x80;MCLKOCR|=0x20;}break;  //Fsysclk/32
 170   2          case 64:{MCLKOCR&=0x80;MCLKOCR|=0x40;}break;  //Fsysclk/64
 171   2          case 96:{MCLKOCR&=0x80;MCLKOCR|=0x60;}break;  //Fsysclk/96
 172   2          case 127:{MCLKOCR&=0x80;MCLKOCR|=0x7F;}break; //Fsysclk/127
 173   2        }
 174   1        if(SET_P==0)
 175   1          MCLKOCR&=0x7F;      //配置时钟由P5.4引脚输出
 176   1        else
 177   1          MCLKOCR|=0x80;      //配置时钟由P1.6引脚输出
 178   1        P_SW2&=0x7F;          //结束并关闭XSFR访问
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:42:17 PAGE 4   

 179   1      }
 180          /********************************************************************/
 181          //LCD1602初始化函数LCD1602_init()，无形参和返回值
 182          /********************************************************************/
 183          void LCD1602_init(void)
 184          {
 185   1        LCD1602_Write(0x28,0);delay(10);//数据总线为4位，显示2行，5*7点阵/每字符
 186   1        LCDEN=1;delay(10);              //使能置“1”
 187   1        LCDEN=0;delay(10);              //使能清“0”
 188   1        LCD1602_Write(0x0C,0);delay(10);//设置开显示，不显示光标
 189   1        LCD1602_Write(0x06,0);delay(10);//写入新数据后显示屏整体不移动仅光标右移
 190   1        LCD1602_Write(0x01,0);delay(10);//写入清屏命令
 191   1      }
 192          /********************************************************************/
 193          //显示字符函数LCD1602_DIS()，无形参和返回值
 194          /********************************************************************/
 195          void LCD1602_DIS(void)
 196          {
 197   1        u8 i;                 //定义控制循环变量i
 198   1        LCD1602_Write(0x80,0);//选择第一行
 199   1        delay(5);             //延时等待1602稳定
 200   1        for(i=0;i<16;i++)
 201   1        {
 202   2            LCD1602_Write(table1[i],1);//写入table1[]内容
 203   2            delay(1);
 204   2        }
 205   1        LCD1602_Write(0xC0,0);//选择第二行
 206   1        delay(5);             //延时等待1602稳定
 207   1        for(i=0;i<16;i++)
 208   1        {
 209   2            LCD1602_Write(table2[i],1);//写入table2[]内容
 210   2            delay(1);
 211   2        }
 212   1      }
 213          /********************************************************************/
 214          //写入液晶模组命令或数据函数LCD1602_Write()，有形参cmdordata
 215          //和writetype，无返回值
 216          /********************************************************************/
 217          void LCD1602_Write(u8 cmdordata,u8 writetype)
 218          {
 219   1        u8 temp=0;                //定义数据处理中间变量
 220   1        LCDRS=writetype;          //判断写入类型0为命令1为数据
 221   1        delay(2);                 //延时等待稳定
 222   1        LCDDATA&=0xF0;            //清数据引脚
 223   1        temp=cmdordata>>4;        //高四位移到低四位
 224   1        LCDDATA|=temp&0x0F;       //写高四位
 225   1        LCDEN=1;delay(2);         //使能置“1”
 226   1        LCDEN=0;delay(2);         //使能清“0”
 227   1        LCDDATA&=0xF0;            //清数据引脚
 228   1        LCDDATA|=cmdordata&0x0F;  //写低四位
 229   1        LCDEN=1;delay(2);         //使能置“1”
 230   1        LCDEN=0;delay(2);         //使能清“0”
 231   1      }
 232          /********************************************************************/
 233          //设定地址写入字符函数LCD1602_DIS_CHAR()，有形参x、y、z无返回值
 234          //x表示1602液晶的行，y表示列地址，z表示欲写入的字符
 235          /********************************************************************/
 236          void LCD1602_DIS_CHAR(u8 x,u8 y,u8 z)
 237          {
 238   1        u8 address;
 239   1        if(x==1)            //若欲显示在第一行
 240   1          address=0x80+y;   //第一行的行首地址+列地址
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:42:17 PAGE 5   

 241   1        else
 242   1          address=0xC0+y;   //第二行的行首地址+列地址
 243   1        LCD1602_Write(address,0);   //设定显示地址
 244   1        LCD1602_Write(z,1); //写入字符数据
 245   1      }
 246          /********************************************************************/
 247          //读卡函数Read_Card()，无形参，有返回值temp
 248          /********************************************************************/
 249          u32 Read_Card(void)
 250          {
 251   1        u8 i=0;                   //起始位循环控制变量
 252   1        u8 timeout;               //超时计数变量
 253   1        u8 timeout_flag;          //超时标志
 254   1        u8 row,col;               //行列变量
 255   1        u8 row_parity;            //行校验变量
 256   1        u8 col_parity[5];         //列校验变量
 257   1        u8 M_data;                //数据位变量
 258   1        u32 temp;                 //卡号变量
 259   1        u32 search=0;             //搜索次数变量
 260   1        while(1)                  //进行完整的读卡过程
 261   1        {   
 262   2          //***************************************************
 263   2          if(search==10)          //若10次搜索都未发现有效数据帧
 264   2            return 0;             //则返回0
 265   2          else                    //否则
 266   2          search++;               //搜索次数值自增
 267   2          timeout=0;              //超时值清零
 268   2          //***************************************************
 269   2          while(Mcode==0)         //等待接收引脚出现低电平
 270   2          {
 271   3            if(timeout==TIME_OUT) //若超时值等于设定阈值
 272   3              break;              //直接跳出本次搜索
 273   3            else                  //若超时值小于设定阈值
 274   3              timeout++;          //超时值自增
 275   3          }
 276   2          //***************************************************
 277   2          if(timeout==100)        //若超时值等于100
 278   2            continue;             //结束本次搜索
 279   2          else                    //否则
 280   2            timeout=0;            //超时值清零
 281   2          //***************************************************
 282   2          delay384us();           //延时384us
 283   2          if(Mcode)               //开始寻找帧头起始位
 284   2          {  
 285   3            for(i=0;i<8;i++)      //循环8次判断和处理过程
 286   3            {   
 287   4              timeout=0;          //先把超时值清零
 288   4              while(Mcode)        //等待接收引脚为高电平
 289   4              { 
 290   5                if(timeout==TIME_OUT)   //若超时值等于设定阈值
 291   5                {   
 292   6                  timeout_flag=1;break; //判定为超时事件，直接退出
 293   6                }
 294   5                else timeout++;   //否则超时值自增
 295   5              }  
 296   4              delay384us();       //再延时384us，判断下一个位
 297   4              if(Mcode&&timeout_flag==0);
 298   4              //判断下一位是否为1且超时标指是否为0
 299   4              else                //两个条件中若有其一不满足
 300   4                break;            //则直接退出         
 301   4            }
 302   3            //***************************************************
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:42:17 PAGE 6   

 303   3            if(timeout_flag)      //若超时标志为1
 304   3            {   
 305   4              timeout_flag=0;continue;//则清零标志并退出本次循环
 306   4            }
 307   3            else;
 308   3            //***************************************************
 309   3            if(i==8)//若i=8，则说明帧头已被识别，现在开始接受数据
 310   3            { 
 311   4              timeout_flag=0;     //清零超时标志
 312   4              timeout=0;          //清零超时值
 313   4              while(Mcode)        //等待接收引脚为高电平
 314   4              {  
 315   5                if(timeout==TIME_OUT)   //若超时值等于设定阈值
 316   5                { 
 317   6                  timeout_flag=0;break; //判定为超时事件，直接退出
 318   6                }
 319   5                else timeout++;   //否则超时值自增
 320   5              }   
 321   4              if(timeout_flag)    //若超时标志为1 
 322   4              {
 323   5                timeout_flag=0;continue;//则清零标志并退出本次循环
 324   5              }
 325   4              else; 
 326   4              //***************************************************
 327   4              //将5个列校验值清零
 328   4              col_parity[0]=col_parity[1]=col_parity[2]=0;
 329   4              col_parity[3]=col_parity[4]=0;
 330   4              for(row=0;row<11;row++)
 331   4              //循环11次，接收11行数据（4个数据位+1个行校验值）
 332   4              {
 333   5                for(col=0,row_parity=0;col<5;col++)//接收数据每5个为一行
 334   5                {
 335   6                  delay384us();       //延时384us，判断下一个数据位
 336   6                  if(Mcode)
 337   6                    M_data=1;         //若接收引脚高电平，则数据位为1
 338   6                  else
 339   6                    M_data=0;         //否则，数据位为0
 340   6                  //***************************************************
 341   6                  if(col<4&&row<10)   //若接收数据位在0-3列且在1-10行内
 342   6                  //意思就是在有效数据区域内
 343   6                  {
 344   7                    temp<<=1;         //卡号变量左移1位
 345   7                    temp+=(u32)M_data;//把新的数据位加到卡号变量中
 346   7                  }
 347   6                  else;
 348   6                  //***************************************************
 349   6                  row_parity+=M_data; //将数据加到行校验变量
 350   6                  col_parity[col]+=M_data;//将数据加到列校验变量
 351   6                  //虽然第5列数据仅作校验，但也加上
 352   6                  timeout=0;          //清零超时值
 353   6                  while(Mcode==(bit)M_data) //等待接收引脚状态为停止位
 354   6                  {
 355   7                    if(timeout==TIME_OUT)   //若超时值等于设定阈值
 356   7                    { 
 357   8                      timeout_flag=1;break; //判定为超时事件，直接退出
 358   8                    }
 359   7                    else timeout++;   //否则超时值自增
 360   7                  }
 361   6                  if(timeout_flag)    //若超时标志为1 
 362   6                    break;            //则退出本次循环
 363   6                  else;
 364   6                }
C51 COMPILER V9.60.0.0   MAIN                                                              06/07/2023 12:42:17 PAGE 7   

 365   5                //***************************************************
 366   5                if(row<10)            //因为最后一行没有校验
 367   5                                      //所以要加限制
 368   5                {
 369   6                  if((row_parity&0x01)||timeout_flag)
 370   6                  //若校验出错或超时标识为1
 371   6                  {
 372   7                    temp=0;           //清零本次采集的卡号数据
 373   7                    timeout_flag=1;   //置位超时标志位
 374   7                    break;            //退出
 375   7                  }
 376   6                  else;
 377   6                }
 378   5                else;
 379   5              }
 380   4              //***************************************************
 381   4              //对最后接收的列校验进行判断并结束本次主循环
 382   4              if(timeout_flag||((col_parity[0]&0x01)&&\
 383   4                (col_parity[1]&0x01)&&(col_parity[2]&0x01)&&\
 384   4              (col_parity[3]&0x01)))
 385   4              {                 //最后一列是没有校验的                         
 386   5                timeout_flag=0; //清零超时标志位
 387   5                temp=0;         //清零本次采集的卡号数据
 388   5                continue;       //退出本次循环
 389   5              } 
 390   4              else
 391   4                return temp;    //将卡号数据返回
 392   4            }
 393   3            continue;           //退出本次循环
 394   3          }
 395   2          continue;             //退出本次循环
 396   2        }
 397   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1947    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     50      24
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
